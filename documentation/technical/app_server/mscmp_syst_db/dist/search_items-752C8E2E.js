searchNodes=[{"doc":"Builds database sources into their respective migrations according to build plans. Options: --type or -t : The type of database to build. This is a required switch and there is no default value. --source or -s : Directory where the buildplans.&lt;type&gt;.toml can be found. If not provided a default directory of database in the project root is assumed. --destination or -d : Directory where to build the migrations. The default value is priv/database is used if not provided. Note that the migrations files will be built inside a directory built from both the destination directory from this switch and the database type: &lt;destination&gt;/&lt;type&gt; . --clean or -c : Clean previously created migrations prior to building the migrations. If this flag is not provided, migrations that already exist are skipped and only new migrations are built. When the previous migrations are cleaned out, the build process will create all migrations. Description: This module implements the build process for a modified version of the common &quot;migrations&quot; database development/deployment strategy. In the model implemented here, the developer creates source files in PL/pgSQL and then updates a build plans file which determines how the individual source files are copied into individual migration files which will then be deployed to the database. This allows the developer to treat database source more closely to non-database source code, at least during initial database development. This migrations model allows for creation of multiple, different databases for applications that require more than a single database definition. These multiple database definitions are referred to as database types . This build process expects the source files to be kept within an independent source directory, by default: database of the project root. In addition to the source files, the database directory should also contain TOML files named buildplans.&lt;database type&gt;.toml which define what migrations will be built and in what order the database source files will be copied to them. Each database type will have its own TOML build plans file. The build plan file is a TOML file with an array of tables of [[buildplan]] : [[build_plan]] release = 1 version = 1 update = 0 sponsor = 820 sponsor_modification = 0 load_files = [ &quot;tables/table_one.sql&quot;, {type = &quot;sql&quot;, file = &quot;tables/table_two.sql&quot;}, {type = &quot;plan&quot;, file = &quot;subplans/subplans.component.toml&quot;} ] The fields above are defined as: release - The major version number of the migration. The first element of the migration file name. version - The minor version number of the migration. The second element of the migration file name. update - The patch version number of the migration. The third element of the migration name. sponsor - In cases where specific clients that use the software are able to sponsor client-specific customizations, this field identifies the client sponsoring the change. This element is the fourth element of the migration file name. All sponsor numbers in the range 0 - 1295 are reserved for Muse Systems internal use and some specific values in that range currently have assigned meanings. General public software releases from Muse Systems will have a sponsor value of 820 ( MS in Base 36), software versions including sponsor number 821 ( MT in Base 36) indicate software created for internal, development testing purposes which should never be part of a public release of the software. sponsor_modification - This field allows for sponsored customization to both be versioned and sequenced in the migration process. This is the fifth element of the migration name. For non-sponsored migrations, this field should just be left at zero. load_files - A list of SQL files and sub-plans to include in the build. Collectively, these are &quot;Load File Items&quot;. Each Load File Item may take one of three forms: &quot;path/to/file.sql&quot; - A simple string is interpreted as the path to an SQL file to load into a migration. {type = &quot;sql&quot;, file = &quot;path/to/file.sql&quot;} - This is the same as the simple file path of form 1. Using this form could allow for a slightly cleaner representation if sat in a group of sub-plan Load File Items. {type = &quot;plan&quot;, file = &quot;path/to/subplan.toml&quot;} - In this form the path indicates that the file is a nested build plan, or sub-plan, whose directives should be followed at this location. A sub-plan is itself a normal build plan. By convention, a sub-plan file name should take the form: subplans.&lt;descriptive_name&gt;.toml ; unlike the build plan naming convention, following the sub-plan naming convention is not required. While build plans may be nested arbitrarily deep, a best practice is to only use a single level of nesting. Each table in the array is a specific build plan which will build a single migration. The body of the migration itself is simply the files in the load_files list copied to the migration file in the order of the list. Note that the migration code is wrapped in a PostgreSQL DO block (PL/pgSQL) so source files may use all the capabilities of PostgreSQL anonymous blocks as are they subject to its limitations. Later, on deployment, the migrations will be applied in migration name order. The migration name is constructed from the versioning information in the buildplan table with each of the versioning fields (recorded as integers) being added in their zero padded, base-36 representations.","ref":"Mix.Tasks.Builddb.html","title":"Mix.Tasks.Builddb","type":"task"},{"doc":"Callback implementation for Mix.Task.run/1 .","ref":"Mix.Tasks.Builddb.html#run/1","title":"Mix.Tasks.Builddb.run/1","type":"function"},{"doc":"Defines the common functions which should be implemented for all custom DbTypes implemented in MscmpSystDb.","ref":"MscmpSystDb.DbTypes.html","title":"MscmpSystDb.DbTypes","type":"protocol"},{"doc":"Compares two values and returns the effective operating describing the relationship. Parameters left - a range type or base type for use in the comparison which would be the left side when used with an infix operator such as &gt; . right - a range type or base type for use in the comparison which would be the right side when used with an infix operator such as &gt; . Examples Comparing two ranges where the left and right overlap, but the left side is less than the right (returns &quot;Less Than Overlapping&quot;). iex&gt; left_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 10 , ...&gt; upper : 100 ...&gt; } iex&gt; right_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 20 , ...&gt; upper : 200 ...&gt; } iex&gt; MscmpSystDb.DbTypes . compare ( left_range , right_range ) :lto Comparing a range and a base type value where the range contains the base type value (returns &quot;Left Contains Right&quot;). iex&gt; left_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 10 , ...&gt; upper : 100 ...&gt; } iex&gt; MscmpSystDb.DbTypes . compare ( left_range , 50 ) :lcr Comparing interval base types where the left is less than the right (returns &quot;Less Than&quot;) iex&gt; left_interval = ...&gt; % MscmpSystDb.DbTypes.Interval { ...&gt; days : 1 ...&gt; } iex&gt; right_interval = ...&gt; % MscmpSystDb.DbTypes.Interval { ...&gt; months : 1 ...&gt; } iex&gt; MscmpSystDb.DbTypes . compare ( left_interval , right_interval ) :lt","ref":"MscmpSystDb.DbTypes.html#compare/2","title":"MscmpSystDb.DbTypes.compare/2","type":"function"},{"doc":"Compares two values and tests the resulting effective operator against that supplied by the user returning true or false . Parameters left - a range type or base type for use in the comparison which would be the left side when used with an infix operator such as &gt; . right - a range type or base type for use in the comparison which would be the right side when used with an infix operator such as &gt; . operator - the desired operator to test. Examples Comparing two ranges where the left and right overlap, but the left side is less than the right. In this case we match the desired &quot;Less Than Overlapping&quot; operator resulting in a return value of true . iex&gt; left_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 10 , ...&gt; upper : 100 ...&gt; } iex&gt; right_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 20 , ...&gt; upper : 200 ...&gt; } iex&gt; MscmpSystDb.DbTypes . test_compare ( left_range , right_range , :lto ) true Comparing a range and a base type value where the range contains the base type value, but the desired operator is &quot;Greater Than&quot; which does not match resulting in a return value of false . iex&gt; left_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 10 , ...&gt; upper : 100 ...&gt; } iex&gt; MscmpSystDb.DbTypes . test_compare ( left_range , 50 , :gt ) false Comparing interval base types where the intervals are equal and testing for equality resulting a true result. iex&gt; left_interval = ...&gt; % MscmpSystDb.DbTypes.Interval { ...&gt; secs : 100 ...&gt; } iex&gt; right_interval = ...&gt; % MscmpSystDb.DbTypes.Interval { ...&gt; secs : 100 ...&gt; } iex&gt; MscmpSystDb.DbTypes . test_compare ( left_interval , right_interval , :eq ) true","ref":"MscmpSystDb.DbTypes.html#test_compare/3","title":"MscmpSystDb.DbTypes.test_compare/3","type":"function"},{"doc":"","ref":"MscmpSystDb.DbTypes.html#t:t/0","title":"MscmpSystDb.DbTypes.t/0","type":"type"},{"doc":"Defines the common functions which should be implemented for all database range types.","ref":"MscmpSystDb.DbTypes.Range.html","title":"MscmpSystDb.DbTypes.Range","type":"protocol"},{"doc":"Compares a range with either a range or related base type and returns a map indicating the applicable comparison operator for the lower and upper bound of the range. Examples Comparing two ranges where both the lower and upper values of the left range are less than the corresponding values of the right side. iex&gt; left_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 10 , ...&gt; upper : 100 ...&gt; } iex&gt; right_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 20 , ...&gt; upper : 200 ...&gt; } iex&gt; MscmpSystDb.DbTypes.Range . bounds_compare ( left_range , right_range ) %{ lower_comparison : :lt , upper_comparison : :lt } Comparing a range value on the left side with a base value on the right. In this case the left side value is less than the right side value, but equal to the upper left side value. iex&gt; left_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 10 , ...&gt; upper : 100 , ...&gt; upper_inclusive : false ...&gt; } iex&gt; MscmpSystDb.DbTypes.Range . bounds_compare ( left_range , 99 ) %{ lower_comparison : :lt , upper_comparison : :eq } Comparing two ranges where the right side range is contained by the left side range. The left side lower bound is less than the right side lower bound and the left side upper bound is greater than the right side upper bound. iex&gt; left_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 10 , ...&gt; upper : 100 , ...&gt; upper_inclusive : false ...&gt; } iex&gt; right_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 20 , ...&gt; upper : 50 ...&gt; } iex&gt; MscmpSystDb.DbTypes.Range . bounds_compare ( left_range , right_range ) %{ lower_comparison : :lt , upper_comparison : :gt }","ref":"MscmpSystDb.DbTypes.Range.html#bounds_compare/2","title":"MscmpSystDb.DbTypes.Range.bounds_compare/2","type":"function"},{"doc":"Extracts and returns the lower bound of a range. Examples iex&gt; range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 10 , ...&gt; upper : 100 , ...&gt; upper_inclusive : false ...&gt; } iex&gt; MscmpSystDb.DbTypes.Range . lower ( range ) 10","ref":"MscmpSystDb.DbTypes.Range.html#lower/1","title":"MscmpSystDb.DbTypes.Range.lower/1","type":"function"},{"doc":"Extracts and returns the upper bound of a range. Examples iex&gt; range = ...&gt; % MscmpSystDb.DbTypes.DecimalRange { ...&gt; lower : Decimal . new ( &quot;11.55&quot; ) , ...&gt; upper : Decimal . new ( &quot;75.50&quot; ) , ...&gt; upper_inclusive : false ...&gt; } iex&gt; MscmpSystDb.DbTypes.Range . upper ( range ) % Decimal { coef : 7549 , exp : - 2 , sign : 1 }","ref":"MscmpSystDb.DbTypes.Range.html#upper/1","title":"MscmpSystDb.DbTypes.Range.upper/1","type":"function"},{"doc":"","ref":"MscmpSystDb.DbTypes.Range.html#t:t/0","title":"MscmpSystDb.DbTypes.Range.t/0","type":"type"},{"doc":"MscmpSystDb - Database Migrations, Connectivity, and Querying A database management Component for developing and managing database-per-tenant oriented systems. To achieve this we wrap and extend the popular Ecto and EctoSql libraries with a specialized templated ( EEx ) migrations system and add additional, opinionated abstractions encapsulating the tenant model as it relates to development, data access, and runtime concerns. Important &quot;Database-per-tenant&quot; is not the typical tenancy implementation pattern for Elixir/Phoenix based applications. As with most choices in software architecture and engineering there are trade-offs between the different tenancy approaches that you should be well-versed with prior to committing to this or any other tenancy model for your applications. Concepts There are several concepts requiring definitions which should be understood before continuing. Most of these concepts relate to runtime concerns though understanding them will inform your sense of the possibilities and constraints on development and deployment scenarios. Datastore A Datastore can most simply be thought of as a single database created to support either a tenant environment or an administrative function of the application. More specifically speaking, a Datastore establishes a store of data and a security boundary at the database level for the data of a tenant or of administrative functionality. Using MscmpSystDb.create_datastore/2 automatically will create the database backing the Datastore. Datastores and the Ecto dynamic repositories which back them are started and stopped at runtime using this Component's API. Datastores are not typically started directly via OTP application related functionality at application startup. This is chiefly because we don't assume to even know what Datastores actually exist until we've started up an administrative Datastore which records the information. Datastore Context A Datastore Context represents a PostgreSQL database role which is used to establish Datastore access and security contexts using database security features. Datastore Contexts are specific to a single Datastore and are managed by the this Component, including the creation, maintenance, and dropping of them as needed, typically in conjunction with Datastore creation/deletion. Behind the scenes Datastore Contexts use the &quot;Ecto Dynamic Repositories&quot; feature. Each Datastore Context is backed by an Ecto Dynamic Repo. Starting a Datastore Context starts its Ecto Dynamic Repo including establishing the connections to the database. Stopping a Datastore Context shuts that associated Dynamic Repo down and terminates its database connections. There are several different kinds of Datastore Contexts which can be defined: Owner : This kind of Datastore Context creates a database role to serve as the database owner of all the database objects backing the Datastore making it the de facto admin role for the Datastore. While the Owner Datastore Context owns the database objects backing the Datastore, it is only a regular database role (no special database rights) and it cannot be a database login role itself. All Datastores must have exactly one Owner Datastore Context defined. Login : The Login Datastore Context is a regular database role with which the application can log into the database and perform operations allowed by the database security policies established by the database developer. There can be one or more Login Datastore Contexts in order to support various security profiles that the application may assume or in order to build connection pools with varying limits depending on some application specific need (e.g. connections support web user interface vs. connections supporting external API interactions.). For a Datastore to be useful there must be at least one Login Datastore Context defined for the Datastore. Non-Login : While the Owner Datastore Context is required, there are other possible scenarios where non-login roles could be useful in managing access to specific database objects, but how useful Non-Login roles might be will depend on application specific factors; the expectation is that their use will be rare. Naturally, there is no requirement for Non-Login Datastore Contexts to be defined for any Datastore. Finally, when we access the database from the application we'll always be doing so identifying one of our Login Datastore Contexts. This is done using MscmpSystDb.put_datastore_context/1 which behind the scenes is using the Ecto.Repo dynamic repository features ( Ecto.Repo.put_dynamic_repo/1 ). Note that there is no default Ecto Repo, dynamic or otherwise, defined in the system. Any attempts to access a Datastore Context without having established the current Datastore Context for the process will cause the process to crash. Warning! Datastore Contexts are created and destroyed by the application using the API functions in this Component. The current implementation of Login Datastore Contexts, however, is expected to have certain security weaknesses related to database role credential management. With this in mind, do not look to our implementation as an example of how to approach such a problem until this and other warnings disappear. The reality is that while in certain on-premise scenarios our current approach might well be workable, it was designed with the idea of kicking the can of a difficult and sensitive problem down the road and not as a final solution that we'd stand behind. We do believe this problem is solvable with sufficient time and expertise. Database Development Our development model assumes that there are fundamentally two phases of development related to the database: Initial/Major Development and Ongoing Maintenance . Initial/Major Development When initially developing a database schema, prior to any releases of usable software the typical &quot;migrations&quot; oriented development pattern of a continuing sequence of incremental changes is significantly less useful than it is during later, maintenance oriented phases of development. During initial development it is more useful to see database schema changes through the lens of traditional source control methodologies. The extend to which this is true will naturally vary depending on the application. Larger, database-centric applications will benefit from this phase of development significantly more than smaller applications where the database is simple persistence and data isn't significant beyond this persistence support role. Ongoing Maintenance Once there is an active release of the software and future deployments will be focused on maintaining already running databases, our model shifts to the norms typical of the traditional migrations database development model. We expect smaller, relatively independent changes which are simply applied in sequence. Unlike other migration tools such as the migrator built into EctoSql , we have some additional ceremony related to sequencing migrations, but aside from these minor differences our migrations will resemble those of other tools once in the maintenance phase of development. Note Despite the discussion above, the distinction between &quot;Initial/Major Development&quot; and &quot;Ongoing Maintenance&quot; is a distinction in developer practice only; the tool itself doesn't make this distinction but merely is designed to work in a way which supports a workflow recognizing these phases. The cost of being able to support the Initial/Major Development concept is that migrations are not numbered or sequenced automatically as will be shown below. If you don't need the Initial/Major Development phase, the traditional EctoSql migrator may be more suitable to your needs. Source Files &amp; Building Migrations Overview In the more typical migrations model, the migration files are themselves the source code of the database changes. This Component separates the two concepts: Database source code files are written by the developer as the developer sees fit. Database source files are what we are most concerned with from a source control perspective; and these files can be freely modified and changes committed up to the point that they are built into released migrations. Database source files are written in (mostly) plain SQL; EEx tags are allowed in the SQL and can be bound during migration time. Once the database source code has reached some stage of completion, the developer can use the mix builddb task to generate migration files from the database sources. In order to build the migration files, the developer will create a TOML &quot;build plan&quot; file which indicates which database source files to include in the migrations and their sequence. For more about the build process and build plans see the mix builddb task documentation. Now let's connect this back to the development phases discussed previously. During the &quot;Initial/Major Development&quot; phase, we expect that there will be many database source files and that these files will be written, committed to source control, modified, and re-committed to source control not as migrations but as you would any other source file (for example, maybe one file per table.); we might also be building migration files at this time for testing purposes, but until the application is released we'd expect the migration files to be cleaned out and rebuilt. Finally once tests, code, reviews, etc. are complete and a release is ready to be prepared, a final mix builddb is run to create the release migrations and those migrations are committed to source control. From this point forward we generally wouldn't modify the original database source files or the final release migrations: the release migrations are essentially set in stone once they may be deployed to a environment where dropping the database is not an option. Subsequent development in the &quot;Ongoing Maintenance&quot; phase looks similar to traditional migration development. For any modification to the database you'll create new a database source file(s) for those modifications specifically and they'll get new version numbers which will in turn create new migrations when mix builddb builds them. These will then be deployed to the database as standard migrations would. Migration Deployments Once built, migration files are deployed to a database similar to the way traditional migration systems perform their deployments: the migrations are checked, in migration number order, against a special database table listing the previously deployed migrations (table ms_syst_db.migrations ). If a migration has been previously deployed, it's skipped and the deployment process moves onto the next migration; if the migration needs to be deployed it is applied to the database and, assuming successful deployment, the process moves onto the next migration or exits when all outstanding migrations have been applied. Each individual migration is applied in a single database transaction. This means that if part of a migration fails to apply to the database successfully, the entire migration is rolled back and the database will be in the state of the last fully successful migration application. A migration application failure will abort the migration process, cancelling the attempted application of migrations after the failed migration. Unlike the EctoSql based migration process, migrations in MscmpSystDb are expected to be managed at runtime by the application. There is no external mix oriented migration deployment process. Migration processes are started for each tenant database individually allowing for selective application of migrations to the specified environment or allowing for &quot;upgrade window&quot; style functionality. Migrations are also EEx templates and template bindings can be supplied to the migrator to make each deployment specific to the database being migrated if appropriate. Naturally, much depends on the broader application design, but the migrator can support a number of different scenarios for deployment of database changes. Finally, the migrator, can in a single application, manage and migrate different database schemas/migration sets depending on the identified &quot;type&quot;. This means that different database schemas for different subsystems can be supported by the migration system in a single application. This assumes that a single database is of a single type; that type may be any of the available types, but mixing of types in a single database is not allowed. Custom Database Types Ecto , EctoSql , and the underlying PostgreSQL library Postgrex offer decent PostgreSQL data type support out of box, but they don't directly map some of the database types that can be helpful in business software such as PostgreSQL range types, internet address types, and interval types. To this end we add some custom database data types via the modules in the MscmpSystDb.DbTypes.* namespace. Data Access Interface The Ecto library offers a data access and manipulation API via the Ecto.Repo module. We wrap and in some cases extend the majority of that functionality in this Component as documented in the Query section . As a rule of thumb, you want to call on this module for such needs even if the same can be achieved with the Ecto library. This recommendation is not meant to suggest that you shouldn't use the Ecto.Query related DSL or methods for constructing queries; using the Ecto Query DSL is, in fact, recommended absent compelling reason to do otherwise.","ref":"MscmpSystDb.html","title":"MscmpSystDb","type":"module"},{"doc":"A convenience function that currently wraps the Ecto.Repo.aggregate/4 function.","ref":"MscmpSystDb.html#aggregate/4","title":"MscmpSystDb.aggregate/4","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.all/2 function.","ref":"MscmpSystDb.html#all/2","title":"MscmpSystDb.all/2","type":"function"},{"doc":"Creates a new Datastore along with its contexts. The creation of a new Datastore includes creating new database to back the Datastore and database roles representing each of the Datastore contexts.","ref":"MscmpSystDb.html#create_datastore/2","title":"MscmpSystDb.create_datastore/2","type":"function"},{"doc":"Creates database roles to back all requested Datastore contexts. Usually Datastore contexts are created in the create_datastore/1 call, but over the course of time it is expected that applications may define new contexts as needs change. This function allows applications to add new contexts to existing Datastores.","ref":"MscmpSystDb.html#create_datastore_contexts/3","title":"MscmpSystDb.create_datastore_contexts/3","type":"function"},{"doc":"Retrieves either atom name or pid/0 of the currently established Datastore context, unless no context has been established.","ref":"MscmpSystDb.html#current_datastore_context/0","title":"MscmpSystDb.current_datastore_context/0","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.delete/2 function.","ref":"MscmpSystDb.html#delete/2","title":"MscmpSystDb.delete/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.delete!/2 function.","ref":"MscmpSystDb.html#delete!/2","title":"MscmpSystDb.delete!/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.delete_all/2 function.","ref":"MscmpSystDb.html#delete_all/2","title":"MscmpSystDb.delete_all/2","type":"function"},{"doc":"Drops a Datastore along with its contexts. Dropping a Datastore will drop the database backing the Datastore from the database server as well as all of the database roles associated defined by the provided database options. Prior to dropping the Datastore, all active connections to the Datastore should be terminated or the function call could fail. Note that this is am irreversible, destructive action. Any successful call will result in data loss.","ref":"MscmpSystDb.html#drop_datastore/2","title":"MscmpSystDb.drop_datastore/2","type":"function"},{"doc":"Drops the requested Datastore contexts. This function will drop the database roles from the database server that correspond to the requested Datastore contexts. You should be sure that the requested Datastore contexts do not have active database connections when calling this function as active connections are likely to result in an error condition.","ref":"MscmpSystDb.html#drop_datastore_contexts/3","title":"MscmpSystDb.drop_datastore_contexts/3","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.exists?/2 function.","ref":"MscmpSystDb.html#exists?/2","title":"MscmpSystDb.exists?/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.get/3 function.","ref":"MscmpSystDb.html#get/3","title":"MscmpSystDb.get/3","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.get!/3 function.","ref":"MscmpSystDb.html#get!/3","title":"MscmpSystDb.get!/3","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.get_by/3 function.","ref":"MscmpSystDb.html#get_by/3","title":"MscmpSystDb.get_by/3","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.get_by!/3 function.","ref":"MscmpSystDb.html#get_by!/3","title":"MscmpSystDb.get_by!/3","type":"function"},{"doc":"Returns the state of the requested contexts. This function will check for each given context that: it exist, whether or not database connections may be started for it, and whether or not database connections have been started. Note that only startable contexts are included in this list. If the context is not startable or has id: nil , the context will be excluded from the results of this function.","ref":"MscmpSystDb.html#get_datastore_context_states/2","title":"MscmpSystDb.get_datastore_context_states/2","type":"function"},{"doc":"Returns the state of the database and database roles which back the Datastore and contexts, respectively, of the provided Datastore options definition.","ref":"MscmpSystDb.html#get_datastore_state/2","title":"MscmpSystDb.get_datastore_state/2","type":"function"},{"doc":"Returns the most recently installed database migration version number. The version is returned as the string representation of our segmented version number in the format RR.VV.UUU.SSSSSS.MMM where each segment represents a Base 36 number for specific versioning purposes. The segments are defined as: RR - The major feature release number in the decimal range of 0 - 1,295. VV - The minor feature version within the release in the decimal range of 0 - 1,295. UUU - The update patch number of the specified release/version in the decimal range of 0 - 46,655. SSSSSS - Sponsor or client number for whom the specific migration or version is being produced for in the decimal range of 0 - 2,176,782,335. MMM - Sponsor modification number in the decimal range of 0 - 46,655. See mix builddb for further explanation version number segment meanings.","ref":"MscmpSystDb.html#get_datastore_version/2","title":"MscmpSystDb.get_datastore_version/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.in_transaction?/0 function.","ref":"MscmpSystDb.html#in_transaction?/0","title":"MscmpSystDb.in_transaction?/0","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.insert/2 function.","ref":"MscmpSystDb.html#insert/2","title":"MscmpSystDb.insert/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.insert!/2 function.","ref":"MscmpSystDb.html#insert!/2","title":"MscmpSystDb.insert!/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.insert_all/3 function.","ref":"MscmpSystDb.html#insert_all/3","title":"MscmpSystDb.insert_all/3","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.insert_or_update/2 function.","ref":"MscmpSystDb.html#insert_or_update/2","title":"MscmpSystDb.insert_or_update/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.insert_or_update!/2 function.","ref":"MscmpSystDb.html#insert_or_update!/2","title":"MscmpSystDb.insert_or_update!/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.load/2 function.","ref":"MscmpSystDb.html#load/2","title":"MscmpSystDb.load/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.one/2 function.","ref":"MscmpSystDb.html#one/2","title":"MscmpSystDb.one/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.one!/2 function.","ref":"MscmpSystDb.html#one!/2","title":"MscmpSystDb.one!/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.preload/3 function.","ref":"MscmpSystDb.html#preload/3","title":"MscmpSystDb.preload/3","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.prepare_query/3 function.","ref":"MscmpSystDb.html#prepare_query/3","title":"MscmpSystDb.prepare_query/3","type":"function"},{"doc":"Establishes the Datastore Context to use for Datastore interactions in the Elixir process where this function is called. Using this function will set the given Datastore Context in the Process Dictionary of the process from which the function call is made.","ref":"MscmpSystDb.html#put_datastore_context/1","title":"MscmpSystDb.put_datastore_context/1","type":"function"},{"doc":"Executes a database query and returns all rows.","ref":"MscmpSystDb.html#query_for_many/3","title":"MscmpSystDb.query_for_many/3","type":"function"},{"doc":"Executes a database query and returns all rows. Raises on error.","ref":"MscmpSystDb.html#query_for_many!/3","title":"MscmpSystDb.query_for_many!/3","type":"function"},{"doc":"Executes a database query but returns no results.","ref":"MscmpSystDb.html#query_for_none/3","title":"MscmpSystDb.query_for_none/3","type":"function"},{"doc":"Executes a database query but returns no results. Raises on error.","ref":"MscmpSystDb.html#query_for_none!/3","title":"MscmpSystDb.query_for_none!/3","type":"function"},{"doc":"Executes a database query and returns a single row.","ref":"MscmpSystDb.html#query_for_one/3","title":"MscmpSystDb.query_for_one/3","type":"function"},{"doc":"Executes a database query and returns a single row. Raises on error.","ref":"MscmpSystDb.html#query_for_one!/3","title":"MscmpSystDb.query_for_one!/3","type":"function"},{"doc":"Executes a database query returning a single value.","ref":"MscmpSystDb.html#query_for_value/3","title":"MscmpSystDb.query_for_value/3","type":"function"},{"doc":"Executes a database query returning a single value. Raises on error.","ref":"MscmpSystDb.html#query_for_value!/3","title":"MscmpSystDb.query_for_value!/3","type":"function"},{"doc":"Returns the record count of the given queryable argument.","ref":"MscmpSystDb.html#record_count/2","title":"MscmpSystDb.record_count/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.reload/2 function.","ref":"MscmpSystDb.html#reload/2","title":"MscmpSystDb.reload/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.reload!/2 function.","ref":"MscmpSystDb.html#reload!/2","title":"MscmpSystDb.reload!/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.rollback/1 function.","ref":"MscmpSystDb.html#rollback/1","title":"MscmpSystDb.rollback/1","type":"function"},{"doc":"Starts database connections for all of login contexts in the Datastore options.","ref":"MscmpSystDb.html#start_datastore/2","title":"MscmpSystDb.start_datastore/2","type":"function"},{"doc":"Starts a database connection for the specific Datastore context provided.","ref":"MscmpSystDb.html#start_datastore_context/2","title":"MscmpSystDb.start_datastore_context/2","type":"function"},{"doc":"Disconnects the database connections for all of the login Datastore option contexts.","ref":"MscmpSystDb.html#stop_datastore/2","title":"MscmpSystDb.stop_datastore/2","type":"function"},{"doc":"Disconnects the database connection for the specific Datastore context provided.","ref":"MscmpSystDb.html#stop_datastore_context/2","title":"MscmpSystDb.stop_datastore_context/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.stream/2 function.","ref":"MscmpSystDb.html#stream/2","title":"MscmpSystDb.stream/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.transaction/2 function.","ref":"MscmpSystDb.html#transaction/2","title":"MscmpSystDb.transaction/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.update/2 function.","ref":"MscmpSystDb.html#update/2","title":"MscmpSystDb.update/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.update!/2 function.","ref":"MscmpSystDb.html#update!/2","title":"MscmpSystDb.update!/2","type":"function"},{"doc":"A convenience function that currently wraps the Ecto.Repo.update_all/3 function.","ref":"MscmpSystDb.html#update_all/3","title":"MscmpSystDb.update_all/3","type":"function"},{"doc":"Updates a Datastore to the most current version of the given type of Datastore. If a Datastore is already up-to-date, this function is basically a &quot;no-op&quot; that returns the current version. Otherwise, database migrations for the Datastore type are applied until the Datastore is fully upgraded to the most recent schema version.","ref":"MscmpSystDb.html#upgrade_datastore/4","title":"MscmpSystDb.upgrade_datastore/4","type":"function"},{"doc":"Defines public types for use with the MscmpSystDb module.","ref":"MscmpSystDb.Types.html","title":"MscmpSystDb.Types","type":"module"},{"doc":"The comparison operators for both the lower and upper bounds of a range type. There are cases where normal comparisons are too coarse-grained to provide a meaningful result when dealing with ranges. In these cases you need the detailed lower/upper comparison results.","ref":"MscmpSystDb.Types.html#t:bounds_compare_result/0","title":"MscmpSystDb.Types.bounds_compare_result/0","type":"type"},{"doc":"An application wide designation for application defined datastore access accounts.","ref":"MscmpSystDb.Types.html#t:context_name/0","title":"MscmpSystDb.Types.context_name/0","type":"type"},{"doc":"The database role name for the specific access context defined by the context_name() .","ref":"MscmpSystDb.Types.html#t:context_role/0","title":"MscmpSystDb.Types.context_role/0","type":"type"},{"doc":"","ref":"MscmpSystDb.Types.html#t:context_state/0","title":"MscmpSystDb.Types.context_state/0","type":"type"},{"doc":"Defines the available states in which a context may exist. :not_found - The database role backing the context was not found on the Datastore database server. :not_ready - The database role backing the context exists, but is not completely set up yet. This is an interim stage that usually has to cross transaction boundaries. :not_started - When starting contexts the system doesn't check for the existence of each context which in turn means that a start failure could be indicative of either non-existence or some other problem. In these start-up scenarios the state would be :not_started . :ready - The context was found and may be connected to the database, but the database connections for the context have not been started yet. :started - The context was found and database connections for the context have already been started.","ref":"MscmpSystDb.Types.html#t:context_state_values/0","title":"MscmpSystDb.Types.context_state_values/0","type":"type"},{"doc":"Values indicating the state of the database which backs a given Datastore. :not_found - The database for the Datastore does not exist on the database server. :ready - The database is ready for further processing by the migrations subsystem.","ref":"MscmpSystDb.Types.html#t:database_state_values/0","title":"MscmpSystDb.Types.database_state_values/0","type":"type"},{"doc":"Defines an application level security context which maps to a specific database role. Datastore contexts allow the application to access the database using database roles which are limited by their database security configuration. :context_name - the application's identifier for a specific security context. This isn't specific to a particular database, but to the application overall. :description - a user friendly description of the context. :database_role - maps the application context to a specific database role. When establishing a connection to a database, this is the database role name that will be used. :database_password - the password used to connect the :database_role to the database server. :starting_pool_size - the number of database connections to initially open for this context. :start_context - when working with application database connections which are started and pooled at application start time, this value indicates whether or not the specific context should be started as normal. For normal startup to take place, both this value and the :login_context value must be true. This setting is disregarded in operations involving database connections which are established on demand as needed, such as DBA related connections. :login_context - if true , the context is a normal context associated with a database login role and will be used in establishing connections to the database. If false , the context is an administrative context which is only used in security definitions within the database. Database owner roles, roles which own all of the application database tables/functions would typically not be login roles, even though the are highly privileged when their context is active in a database session. (default: true) :database_owner_context - if true the context represents the database owner role. If false or not provided the database role is not used for this purpose. Note that there should only be one context defined as the database owner for any Datastore.","ref":"MscmpSystDb.Types.html#t:datastore_context/0","title":"MscmpSystDb.Types.datastore_context/0","type":"type"},{"doc":"Defines the options required for establishing the database connections which make up a Datastore. :database_name - The name of the database in the database server to which the connection will be made. Often times this value will be the same as the String.t() form of the :datastore_name value. :datastore_code - Defines a Datastore specific salting value for use in certain security and cryptographic related functions. :datastore_name - A name for use by the application to identify a given datastore. This value will often time be the same as the :database_name value, except as an atom() rather than a String.t(). :contexts - A list of available Datastore Context values defining which contexts are available for this Datastore. See datastore_context() for more information concerning the values of each entry in the list. :db_server - The database server information for the server where the Datastore database resides. See db_server() for additional details.","ref":"MscmpSystDb.Types.html#t:datastore_options/0","title":"MscmpSystDb.Types.datastore_options/0","type":"type"},{"doc":"Represents a specific database server. The data in the map includes fields which uniquely identifies the server, provides information for where on the network the server can be found, and connection related parameters. Also, the full administrative credentials are included. :server_name - Provides a unique identifier for a database server instance. :start_server_instances - If true, indicates that databases on the server can be started and made available as application Datastores. :server_pools - The server pools in which the database server participates. :db_host - The hostname or IP address of the database server on the network. :db_port - The TCP port on which the database server is listening for connections. :db_show_sensitive - If true, various logging events may show unredacted &quot;sensitive&quot; database connectivity information. Note that even when false, the application still log sensitive application data. :db_max_instances - The total number of databases allowed to be established for the db_server instance. :server_salt - For certain cryptographic operations, such as password derivation, allows for the assignment of specific salting value for that is specific to a given database server. This value must be at least 32 bytes long and should be a random string. :dbadmin_password - The ms_syst_privileged role password for privileged operations such as creating a new database/Datastore or new database roles on the database server instance. :dbadmin_pool_size - The pool size to use for creating connections for privileged operations using the ms_syst_privileged role.","ref":"MscmpSystDb.Types.html#t:db_server/0","title":"MscmpSystDb.Types.db_server/0","type":"type"},{"doc":"Defines operators for use in comparison functions. These operators are used in conjunction with the MscmpSystDb.DbTypes and MscmpSystDb.DbTypes.Range protocols. The range related operator values are generally the same as those defined by the PostgreSQL database range types, but there are some small differences. :gt - left is greater than right. :lt - left is less than right. :eq - the values are equal. :lcr - left contains right. :rcl - right contains left. :gto - greater than overlapping. :lto - less than overlapping. Examples Greater Than ( :gt ) iex&gt; left_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 200 , ...&gt; upper : 210 ...&gt; } iex&gt; right_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 100 , ...&gt; upper : 110 ...&gt; } iex&gt; MscmpSystDb.DbTypes . compare ( left_range , right_range ) :gt Less Than ( :lt ) iex&gt; left_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 100 , ...&gt; upper : 110 ...&gt; } iex&gt; right_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 200 , ...&gt; upper : 210 ...&gt; } iex&gt; MscmpSystDb.DbTypes . compare ( left_range , right_range ) :lt Equal ( :eq ) iex&gt; left_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 100 , ...&gt; upper : 110 ...&gt; } iex&gt; right_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 100 , ...&gt; upper : 110 ...&gt; } iex&gt; MscmpSystDb.DbTypes . compare ( left_range , right_range ) :eq Left Contains Right ( :lcr ) iex&gt; left_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 90 , ...&gt; upper : 110 ...&gt; } iex&gt; right_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 100 , ...&gt; upper : 110 ...&gt; } iex&gt; MscmpSystDb.DbTypes . compare ( left_range , right_range ) :lcr Right Contains Left ( :rcl ) iex&gt; left_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 100 , ...&gt; upper : 110 ...&gt; } iex&gt; right_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 100 , ...&gt; upper : 111 ...&gt; } iex&gt; MscmpSystDb.DbTypes . compare ( left_range , right_range ) :rcl Greater Than Overlapping ( :gto ) iex&gt; left_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 150 , ...&gt; upper : 250 ...&gt; } iex&gt; right_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 100 , ...&gt; upper : 175 ...&gt; } iex&gt; MscmpSystDb.DbTypes . compare ( left_range , right_range ) :gto Less Than Overlapping ( :lto ) iex&gt; left_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 100 , ...&gt; upper : 150 ...&gt; } iex&gt; right_range = ...&gt; % MscmpSystDb.DbTypes.IntegerRange { ...&gt; lower : 125 , ...&gt; upper : 175 ...&gt; } iex&gt; MscmpSystDb.DbTypes . compare ( left_range , right_range ) :lto","ref":"MscmpSystDb.Types.html#t:db_type_comparison_operators/0","title":"MscmpSystDb.Types.db_type_comparison_operators/0","type":"type"},{"doc":"Defines the available states in which a Datastore might exist in relation to its schema migrations. :not_initialized - The Datastore does not have the table which manages the migrations installed. This is also the value reported when the database_state_values() value for the Datastore is :not_found . :not_updated - The Datastore database exists and has been initialized, but does not have the most recent migrations available applied per the migrations management table. :ready - The migrations are fully up-to-date and the Datastore is ready to serve the application as needed.","ref":"MscmpSystDb.Types.html#t:migration_state_values/0","title":"MscmpSystDb.Types.migration_state_values/0","type":"type"},{"doc":"Options which are expected by the Timex library. The MscmpSystDb.DbTypes.Interval struct can be converted into a form which can be consumed by Timex.shift/2 and this type defines the possible return values. Note that this type should closely match the t:Timex.shift_options types except that we limit it to the types present in the t:MscmpSystDb.DbTypes.Interval.t data type.","ref":"MscmpSystDb.Types.html#t:timex_shift_options/0","title":"MscmpSystDb.Types.timex_shift_options/0","type":"type"},{"doc":"An Elixir representation of the PostgreSQL daterange data type. Derived from the Postgrex.Range data type. For more information about this data type, see: The PostgreSQL Documentation: Range Types This type implements the MscmpSystDb.DbTypes protocol.","ref":"MscmpSystDb.DbTypes.DateRange.html","title":"MscmpSystDb.DbTypes.DateRange","type":"module"},{"doc":"Callback implementation for Ecto.Type.embed_as/1 .","ref":"MscmpSystDb.DbTypes.DateRange.html#embed_as/1","title":"MscmpSystDb.DbTypes.DateRange.embed_as/1","type":"function"},{"doc":"Callback implementation for Ecto.Type.equal?/2 .","ref":"MscmpSystDb.DbTypes.DateRange.html#equal?/2","title":"MscmpSystDb.DbTypes.DateRange.equal?/2","type":"function"},{"doc":"","ref":"MscmpSystDb.DbTypes.DateRange.html#t:t/0","title":"MscmpSystDb.DbTypes.DateRange.t/0","type":"type"},{"doc":"An Elixir representation of the PostgreSQL tstzrange data type. Derived from the Postgrex.Range data type. For more information about this data type, see: The PostgreSQL Documentation: Range Types","ref":"MscmpSystDb.DbTypes.DateTimeRange.html","title":"MscmpSystDb.DbTypes.DateTimeRange","type":"module"},{"doc":"Callback implementation for Ecto.Type.embed_as/1 .","ref":"MscmpSystDb.DbTypes.DateTimeRange.html#embed_as/1","title":"MscmpSystDb.DbTypes.DateTimeRange.embed_as/1","type":"function"},{"doc":"Callback implementation for Ecto.Type.equal?/2 .","ref":"MscmpSystDb.DbTypes.DateTimeRange.html#equal?/2","title":"MscmpSystDb.DbTypes.DateTimeRange.equal?/2","type":"function"},{"doc":"","ref":"MscmpSystDb.DbTypes.DateTimeRange.html#t:t/0","title":"MscmpSystDb.DbTypes.DateTimeRange.t/0","type":"type"},{"doc":"An Elixir representation of the PostgreSQL numrange data type. Derived from the Postgrex.Range data type. For more information about this data type, see: The PostgreSQL Documentation: Range Types","ref":"MscmpSystDb.DbTypes.DecimalRange.html","title":"MscmpSystDb.DbTypes.DecimalRange","type":"module"},{"doc":"Callback implementation for Ecto.Type.embed_as/1 .","ref":"MscmpSystDb.DbTypes.DecimalRange.html#embed_as/1","title":"MscmpSystDb.DbTypes.DecimalRange.embed_as/1","type":"function"},{"doc":"Callback implementation for Ecto.Type.equal?/2 .","ref":"MscmpSystDb.DbTypes.DecimalRange.html#equal?/2","title":"MscmpSystDb.DbTypes.DecimalRange.equal?/2","type":"function"},{"doc":"","ref":"MscmpSystDb.DbTypes.DecimalRange.html#t:t/0","title":"MscmpSystDb.DbTypes.DecimalRange.t/0","type":"type"},{"doc":"An Elixir representation of the PostgreSQL inet and cidr data types. Derived from the Postgrex.INET data type. For more information about this data type, see: The PostgreSQL Documentation: Network Address Types","ref":"MscmpSystDb.DbTypes.Inet.html","title":"MscmpSystDb.DbTypes.Inet","type":"module"},{"doc":"Callback implementation for Ecto.Type.embed_as/1 .","ref":"MscmpSystDb.DbTypes.Inet.html#embed_as/1","title":"MscmpSystDb.DbTypes.Inet.embed_as/1","type":"function"},{"doc":"Callback implementation for Ecto.Type.equal?/2 .","ref":"MscmpSystDb.DbTypes.Inet.html#equal?/2","title":"MscmpSystDb.DbTypes.Inet.equal?/2","type":"function"},{"doc":"Converts a network address represented either as a IP.addr/0 or IP.Subnet.t/0 value into one represented as a MscmpSystDb.DbTypes.Inet.t/0 value.","ref":"MscmpSystDb.DbTypes.Inet.html#from_net_address/1","title":"MscmpSystDb.DbTypes.Inet.from_net_address/1","type":"function"},{"doc":"Converts a network address represented as a Postgrex.INET.t/0 value into one represented as a MscmpSystDb.DbTypes.Inet.t/0 value.","ref":"MscmpSystDb.DbTypes.Inet.html#from_postgrex_inet/1","title":"MscmpSystDb.DbTypes.Inet.from_postgrex_inet/1","type":"function"},{"doc":"Converts a network address represented as a MscmpSystDb.DbTypes.Inet.t/0 value into one represented as either a IP.addr/0 or IP.Subnet.t/0 value.","ref":"MscmpSystDb.DbTypes.Inet.html#to_net_address/1","title":"MscmpSystDb.DbTypes.Inet.to_net_address/1","type":"function"},{"doc":"Converts a network address represented as a MscmpSystDb.DbTypes.Inet.t/0 value into one represented as a Postgrex.INET.t/0 value.","ref":"MscmpSystDb.DbTypes.Inet.html#to_postgrex_inet/1","title":"MscmpSystDb.DbTypes.Inet.to_postgrex_inet/1","type":"function"},{"doc":"","ref":"MscmpSystDb.DbTypes.Inet.html#t:t/0","title":"MscmpSystDb.DbTypes.Inet.t/0","type":"type"},{"doc":"An Elixir representation of the PostgreSQL int8range data type. Derived from the Postgrex.Range data type. For more information about this data type, see: The PostgreSQL Documentation: Range Types","ref":"MscmpSystDb.DbTypes.IntegerRange.html","title":"MscmpSystDb.DbTypes.IntegerRange","type":"module"},{"doc":"Callback implementation for Ecto.Type.embed_as/1 .","ref":"MscmpSystDb.DbTypes.IntegerRange.html#embed_as/1","title":"MscmpSystDb.DbTypes.IntegerRange.embed_as/1","type":"function"},{"doc":"Callback implementation for Ecto.Type.equal?/2 .","ref":"MscmpSystDb.DbTypes.IntegerRange.html#equal?/2","title":"MscmpSystDb.DbTypes.IntegerRange.equal?/2","type":"function"},{"doc":"","ref":"MscmpSystDb.DbTypes.IntegerRange.html#t:t/0","title":"MscmpSystDb.DbTypes.IntegerRange.t/0","type":"type"},{"doc":"An Elixir representation of the PostgreSQL interval data type. Derived from the Postgrex.Interval data type. For more information about this data type, see: The PostgreSQL Documentation: Date/Time Types","ref":"MscmpSystDb.DbTypes.Interval.html","title":"MscmpSystDb.DbTypes.Interval","type":"module"},{"doc":"Callback implementation for Ecto.Type.embed_as/1 .","ref":"MscmpSystDb.DbTypes.Interval.html#embed_as/1","title":"MscmpSystDb.DbTypes.Interval.embed_as/1","type":"function"},{"doc":"Callback implementation for Ecto.Type.equal?/2 .","ref":"MscmpSystDb.DbTypes.Interval.html#equal?/2","title":"MscmpSystDb.DbTypes.Interval.equal?/2","type":"function"},{"doc":"Converts an Interval into a form that can be used by the Timex library's Timex.shift/2 function. Example iex&gt; example_interval = ...&gt; % MscmpSystDb.DbTypes.Interval { months : 1 , days : 1 , secs : 1 , microsecs : 1 } iex&gt; MscmpSystDb.DbTypes.Interval . to_timex_shift_options ( example_interval ) [ months : 1 , days : 1 , seconds : 1 , microseconds : 1 ]","ref":"MscmpSystDb.DbTypes.Interval.html#to_timex_shift_options/1","title":"MscmpSystDb.DbTypes.Interval.to_timex_shift_options/1","type":"function"},{"doc":"","ref":"MscmpSystDb.DbTypes.Interval.html#t:t/0","title":"MscmpSystDb.DbTypes.Interval.t/0","type":"type"},{"doc":"Provides basic OTP related features for Datastores. Functions in this module support running Datastores under supervision and creates a Datastore supervisor for managing Datastore Context worker processes.","ref":"MscmpSystDb.Datastore.html","title":"MscmpSystDb.Datastore","type":"module"},{"doc":"Provides a Datastore child specification for use with supervisors. Note that this function is not child_spec/1 as expected when a Supervisor attempts to start a process based on the module name alone. This is because there is a required parameter which renders that method of starting a process invalid as there's no default value for the parameter ( datastore_options ). Parameters datastore_options - a required Map of values which describe the Datastore and Datastore Context related connection options. See MscmpSystDb.Types.datastore_options/0 for more. opts - a Keyword list of various options accepted or required by the DynamicSupervisor.start_link/1 function. Note that we provide some default values: strategy: :one_for_one , restart: :transient , timeout: 60_000 , and the :name option is defaulted to the datastore_options.datastore_name value.","ref":"MscmpSystDb.Datastore.html#child_spec/2","title":"MscmpSystDb.Datastore.child_spec/2","type":"function"},{"doc":"Starts the Datastore Supervisor and its requested child Datastore Contexts. When this function is called, a new DynamicSupervisor for the datastore is started and any Datastore Contexts which are identified in the datastore_options are also started and places under the Datastore Supervisor. Options name - establishes the name of the Datastore Supervisor and accepts any name which is valid according to the documentation for GenServer . The default value for this parameter is the datastore_name value found in the datastore_options attribute which configures the Datastore. datastore_options - a required Map of values which describe the Datastore and Datastore Context related connection options. See MscmpSystDb.Types.datastore_options/0 for more.","ref":"MscmpSystDb.Datastore.html#start_link/1","title":"MscmpSystDb.Datastore.start_link/1","type":"function"},{"doc":"Provides basic OTP related features for Datastore Contexts. Usually functions in this API are called when processing MscmpSystDb.Datastore module functions. However, there are times when direct Datastore Context manipulation is appropriate, such as stopping and then restarting a specific Context for maintenance reasons.","ref":"MscmpSystDb.DatastoreContext.html","title":"MscmpSystDb.DatastoreContext","type":"module"},{"doc":"Returns the Child Specification used to start the DatastoreContext service. Parameters datastore_options - a required Map of values which describe the Datastore and Datastore Context related connection options. See MscmpSystDb.Types.datastore_options/0 for more. context_name - the identity of the context as understood by the system. The context name is both the identity of the context as an Ecto Repo and is also used for the child specification ID value as there is the possibility of multiple contexts to start under the Datastore Supervisor process. options - a Keyword List of optional values. Currently there are no attributes which are expected in this list and it is safe to omit.","ref":"MscmpSystDb.DatastoreContext.html#child_spec/3","title":"MscmpSystDb.DatastoreContext.child_spec/3","type":"function"},{"doc":"Starts a Datastore Context as a linked process to the caller. Typically this function is called once for each Context defined for a Datastore by the MscmpSystDb.Datastore.start_link/1 function. However there are some cases where starting a Datastore Context independently can be desirable, such as the Context was earlier stopped for some reason and needs to be started under it's original Datastore Supervisor. Options name - see the context_name parameter for MscmpSystDb.DatastoreContext.child_spec/3 . datastore_options - see the datastore_options parameter for MscmpSystDb.DatastoreContext.child_spec/3 . This option is required. context - a required map describing the Context to be started. See t:MscmpSystDb.Types.datastore_context() for more information.","ref":"MscmpSystDb.DatastoreContext.html#start_link/1","title":"MscmpSystDb.DatastoreContext.start_link/1","type":"function"},{"doc":"Provides common attributes for use by most application Ecto Schema instances. Chiefly, we ensure that the primary and foreign keys are all of a common type. To use this module, simply add use MscmpSystDb.Schema in place of use Ecto.Schema .","ref":"MscmpSystDb.Schema.html","title":"MscmpSystDb.Schema","type":"module"}]