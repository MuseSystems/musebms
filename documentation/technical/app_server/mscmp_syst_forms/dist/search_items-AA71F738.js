searchNodes=[{"doc":"MscmpSystForms - User Interface Forms &amp; Components The MscmpSystForms module provides a standard methodology for authoring application user interface forms in support of business systems development. use MscmpSystForms When you use MscmpSystForms , the MscmpSystForms module will set @behaviour MscmpSystForms and the following functions will be created for the using module: update_button_state/3 start_processing_override/2 finish_processing_override/2 update_display_data/3 get_component_info/1 Documentation for these functions is available in the module and they are simply delegates to the same functions (give or take some arity) in MscmpSystForms . Foundational Ideas At the heart of our methodology and support are several key ideas presented here. On &quot;Forms&quot; One thing to be mindful of as you read this section and the documentation generally is our use of the word &quot;Form&quot;. In this documentation we will more often use the word &quot;Form&quot; in the more generic sense of a user interface to a particular subject or feature than to refer to a specific Form Component or something like an HTML form; we will use the word in that manner as well and hopefully context should make clear which sense we mean. Definitions vs. Rendering A &quot;Form&quot; conforming to the MscmpSystForms standard will be defined in two distinct parts: Definitional Concerns Our forms may be complex and include a variety of both informational and input fields (elements) to which different users will have different permission based entitlements. Additionally, some element properties, such as labels, may appear not just along side the element in the user interface but also in tool tips, quick help pages and the like. Some properties, such as permissions or even some runtime display properties can easily be made inheritable from parent elements to child elements; naturally, the idea of virtual elements can be useful in building such hierarchies as well. Having a place to define both these static elements and the inheritance hierarchies between elements without necessarily being coupled to the layout has advantages. We can create a cleaner definition of these properties while reducing the redundancies that defining these attributes in the context of page layout concerns could force on us as well as reducing the noise that display related attributes would necessarily force on us. Rendering Concerns All forms must ultimately be laid out for rendering as the user interface and this area of concern deals with the issues of laying out our form elements. The truth is that the &quot;Rendering Concerns&quot; are really the typical user interface development activities (web or otherwise) that most front end developers will think about and it is the &quot;Definitional Concerns&quot; which we are adding to that process. Form Data It is not uncommon to closely couple database Ecto schema definitions with the presentation and management forms, using the Ecto database schema to directly drive the user interface forms. The problem is that it can force unnatural compromises to either the database structure (assuming that the Ecto Schemas are representative of the underlying table structures) or the user interface forms or both. In our model we view both the database structure and the user interface design as first class concerns and as such our standard is to not directly use Ecto Schemas which define database data to also back forms. We create independent Ecto &quot;Embedded Schemas&quot; to back the forms specifically. It absolutely happens that there can be form schemas and database schemas with high degrees of similarity, but by setting the expectation that we will always have an Embedded Schema defined to back the form ensures that the development of the form avoids the aforementioned conflicts and compromises. Any given form will also have three senses of its data, each of which may differ from each other enough that we track the data for all three purposes: Original Data This is the data which a form initializes with. When creating new records, this will either be empty or populated with the default values defined as the starting place for any new records. For viewing or editing existing data records, this value will be the data as loaded from the database. As the user interacts with the form, these original data values will not change, always reflecting the starting point with which the form was initialized. While not always useful we can use the original data for fallback/reset purposes, to display changes (e.g. percentage changed) relative to the starting data, and similar such purposes. In the form's assigns we represent this using the form backing Ecto embedded schema struct which can be passed as the &quot;data&quot; expected by Ecto.Changeset validation functions. This data is kept by the view including all values regardless of user permissions to see or alter those values. Current Data The current state of the data, including any changes made by the user or system as they interact with the form, but prior to those changes being committed to the database. The starting point of this data when the form initializes is typically the same as the Original Data. As the user interacts with the form, the current data is updated to reflect changes. We usually store this data in the form's assigns as a map as we can pass this directly to the data validation functions ( Ecto.Changeset based) as needed. The current data includes all form data regardless of the user's permissions to view or edit that data. Display Data A representation of the data for the purposes of display to the user in the form. The data values in Display Data are the same as those in Current Data except they are filtered by the user's permissions for data visibility. Display Data is stored in the view's assigns as a Phoenix.HTML.Form.t/0 struct so that it can be accessed directly by the LiveView for rendering. Working with Phoenix The most common use case for MscmpSystForms is for facilitating Phoenix based web and external API user interface development. To understand how MscmpSystForms fits into the Phoenix development model it's important to understand certain assumptions we make about the role of Phoenix in our broader application development paradigm. Important Our thinking and approach to working with Phoenix is not the conventional or generally accepted approach in many ways. Use caution and understand the trade-offs when evaluating our work in this regard. Our development model takes the stance that Phoenix is not the application, but the user interface layer. That layer brings together a lot of dependencies to deliver services, but those dependencies are independently developed as separate Elixir/OTP applications and could be used (in theory) in other contexts. As such our Phoenix application only deals with the presentation of the user interface and wiring that user interface to the actual business/domain logic written elsewhere. In the process some elements which by convention has certain roles within typical Phoenix application development are repurposed to serve our needs better. Developing Forms With our Foundational Ideas having been discussed, we now move on to looking how this translates into form development. Source Organization &amp; File Roles Starting with a standard Phoenix application, to which MscmpSystForms has been added as a dependency, we will have two basic directories (or applications in the case where the Phoenix project is initialized as an umbrella project): my_app , my_app_web . In typical Phoenix applications the web based user interface including views and controllers are built in the my_app_web directory and the business/domain logic (i.e. &quot;contexts&quot;) resides in the my_app directory. We adopt the directories created by mix phx.new , but we change their purpose: my_app_web Hosts view related code. Controller like code is discouraged here. my_app : Hosts controller like logic. Business/Domain Logic is discouraged here and should be developed in external Elixir Projects and included as dependencies in the Phoenix application. Using these directories, and assuming our application has one form ( my_form ), we will create the following basic file structure for our form's source code: my_app_web └ ─ ─ lib └ ─ ─ my_app_web └ ─ ─ live ├ ─ ─ my_form_live . ex └ ─ ─ my_form_live . html . heex my_app └ ─ ─ lib └ ─ ─ msform ├ ─ ─ my_form │ ├ ─ ─ actions . ex │ ├ ─ ─ data . ex │ ├ ─ ─ definitions . ex │ └ ─ ─ types . ex └ ─ ─ my_form . ex Note The example directory structure above has been simplified to focus on those entries important to understanding the MscmpSystForms development model. Other files and directories which are standard for Phoenix development and which would be present but unaltered under our model have been excluded from the example listings. my_app_web In the my_app_web example listing the path my_app_web/lib/my_app_web/live is the standard Phoenix pathing for Phoenix.LiveView pages. While we do make some assumption changes to Phoenix standard practices in regard to what gets done in this directory, those changes are minor and really a matter of convention. Files my_form_live.html.heex this file is a typical Phoenix LiveView Heex file. The only difference from standard Phoenix Heex development is that MscmpSystForms.WebComponents will be used as a source of components rather than the CoreComponents module which comes with Phoenix (though it is available). my_form_live.ex this file is the typical LiveView controller file which backs the LiveView which is home to the LiveView's mount/3 , handle_event/3 , and handle_info/2 functions. The difference under the MscmpSystForms model is that we typically code much less logic directly in this file allowing that logic to exist in the my_app directory hierarchy. Therefore this file is limited to two roles: 1) mapping LiveView events to controller level logic in the my_app code; and 2) values which directly become display issues in the web interface; for example text strings for flash messages related to validation failures might be coded here since we're effectively still in the &quot;view&quot; layer per our definitions. my_app Under our methodology we make the greatest departures from typical Phoenix development in this directory. In typical Phoenix development practice this directory is the home of the business/domain logic, the &quot;model&quot;. For us, however, this is our controller layer, but even more importantly it is where we deal with the &quot;Definitional Concerns&quot; discussed earlier and which is unique to MscmpSystForms based forms. Sub-directories &amp; Files msform This directory holds source files and sub-directories for defining form data, defining the abstract configuration of form components, and includes our form controller logic which calls our externally defined business logic in response to user interactions. For each form, we define a single Elixir source file named after the name of the form it exists to support. We also create a sub-directory also named after the form. msform/my_form.ex This Elixir source file defines a single module in the Msform namespace which implements the MscmpSystForms behavior (typically with use MscmpSystForms ). This module also defines a struct of the form's backing data using Ecto.Schema.embedded_schema/1 so that we can use the fully data mapping and validation capability of both Ecto and Phoenix forms. Finally this module also defines an API for the form which includes the implementation of the MscmpSystForms Behaviour callbacks and functions to expose other controller-like logic as appropriate to the forms specific needs. Note that the API is typically delegating to specific source files and internal modules written in the msform/my_form/*.ex files. msform/my_form/actions.ex This source file typically defines a single module for the form implementing the controller-like actions which are initiated from the user interface or other sources the form should respond to (e.g. PubSub messages). msform/my_form/data.ex Typically defines a single module containing functions which implement form data validation via Changeset processing. msform/my_form/definitions.ex This file contains a single module directed at resolving a form's &quot;Definitional Concerns&quot;. In this module we find the implementation of the MscmpSystForms.get_form_config/0 and MscmpSystForms.get_form_modes/0 functions. msform/my_form/types.ex A module to define/document form specific typespecs. Usually this will at least contain a type parameters for use in typespecs associated with Changeset processing. Since functions like Ecto.Changeset.cast/4 require their 'params' argument to be represented as a map and since we know the possible valid structures of the map we can define a typespec to help documenting that structure.","ref":"MscmpSystForms.html","title":"MscmpSystForms","type":"behaviour"},{"doc":"Removes a processing override from the active overrides list. Once an active operation previously added to the process overrides list has completed its processing, this function is used to remove it from the list so that any user interface components that are watching for the operation to be active can resume their normal behavior. Parameters socket_or_assigns - the socket or assigns for the current view. override - the name of the processing override to remove from the active process overrides list.","ref":"MscmpSystForms.html#finish_processing_override/2","title":"MscmpSystForms.finish_processing_override/2","type":"function"},{"doc":"Retrieves the textual information ( label , label_link , and info ) field values from the Form Configuration for the identified component. This is a convenience function which accepts either a form_id value or a binding_id value and returns the textual information for the component if found by the passed identifier. Parameters module - the name of the form module implementing the MscmpSystForms.get_form_config/0 callback with which form configuration data will be retrieved. component_id - this value is either the form_id or binding_id that is associated with the component for which textual information is being retrieved.","ref":"MscmpSystForms.html#get_component_info/2","title":"MscmpSystForms.get_component_info/2","type":"function"},{"doc":"Returns a list of MscmpSystForms.Types.FormConfig.t/0 structs which represent the abstract configuration of the form. This function is usually simply returns a hard-coded list of MscmpSystForms.Types.FormConfig.t/0 values as defined by the form developer. This function is called by various form rendering related functions to get the starting point for each component from which MscmpSystForms.Types.ComponentConfig.t/0 values will be created by MscmpSystForms.get_render_configs/5 . Note that not all elements in a user interface require representation in the form configuration returned by this function. However, any element not included in the form configuration here will be excluded from responding to any changes in form state, processing overrides, or user permissions. The configurations returned by this function, and the parent/child relationships between individual FormConfig values, should be structured to facilitate the appropriate inheritance of properties from FormConfig parent to child; the goal being to reduce redundant establishment of those properties in the configuration. This will often times result in the data returned by this function being hierarchical and resembling the layout structure of the rendered form even though there is no requirement that the structure of these configurations are related to the rendered layout in any way. Examples Consider the following example configuration: def get_form_config do [ % FormConfig { permission : :form_access_permission , label : &quot;Virtual FormConfig&quot; , children : [ % FormConfig { form_id : :concrete_config_input , binding_id : :data_field_input , label : &quot;Example Input Field&quot; , } , % FormConfig { form_id : :concrete_config_submit_button , label : &quot;Submit&quot; , button_state : :message } ] } ] end At the top level we have a virtual or abstract FormConfig value; we know it's virtual because it defines no form_id value. This top level value exists so that its children can inherit its permission value and its defined display modes (see MscmpSystForms.get_form_modes/0 ). This doesn't mean that the returned configuration represents all elements in the rendered form and the parent in this case, being virtual, doesn't correspond to any rendered form element at all (that would require a form_id value being defined). The overall structure and the virtual element exist to purely support the inheritance of configuration and state related values. While with the structure in the example above, we can take advantage of inherited values, we can selectively override those values as needed. Consider this revision of the first example: def get_form_config do [ % FormConfig { permission : :form_access_permission , label : &quot;Virtual FormConfig&quot; , children : [ % FormConfig { form_id : :concrete_config_input , binding_id : :data_field_input , label : &quot;Example Input Field&quot; , } , % FormConfig { form_id : :concrete_config_submit_button , permission : :form_submit_permission , label : &quot;Submit&quot; , button_state : :message } ] } ] end In the revised example, we don't inherit the the :form_access_permission value of the parent in :concrete_config_submit_button any longer, but now check the :form_submit_permission permission instead. The :concrete_config_submit_button will continue to inherit other values from the parent that it has not explicitly overridden.","ref":"MscmpSystForms.html#c:get_form_config/0","title":"MscmpSystForms.get_form_config/0","type":"callback"},{"doc":"Returns a map of the recognized form states and the display modes each component should take when a given form state is specified. The map returned by this function has a basic hierarchical structure where the Form State feature is at the top level, the Form State mode taking the next level, and the Form State State being nested under mode . In this way each defined feature can have one or more mode entries and each mode entry can have one or more state entries. %{ &lt; feature &gt; : %{ default : %{ &lt; component_form_id &gt; : %{ &lt; default component modes &gt; } } , &lt; mode &gt; : %{ &lt; state &gt; : %{ &lt; component_form_id &gt; : %{ &lt; component modes &gt; } } } , processing_overrides : %{ &lt; component_form_id &gt; : [ &lt; processing override name &gt; ] } } } Mode Structure Rules &amp; Considerations Feature Level Map The Feature level of the map will accept one or more Feature entries where the key for each entry is the name ( MscmpSystForms.Types.form_state_feature_name/0 ) by which the Feature is to be referenced elsewhere in the application code. Most forms are likely to only support a single Feature; in this case simply name the Feature :default as this is the default feature name used when one isn't otherwise provided. The contents of each Feature's map consist of: a single :default key with values establishing the default component modes to use when the other Form State modes fail to define a component mode for a given component. a :processing_overrides key which define the processing overrides the various form components should respond to. one or more &quot;modes&quot; where the key is the Mode name ( MscmpSystForms.Types.form_state_mode_name/0 ) and the value is a map of Form State States which define the various states supported by that Mode. Mode Level Map The Mode level is expressed as a key/value map where the keys are Form State &quot;State&quot; names ( MscmpSystForms.Types.form_state_state_name/0 ) and the values of those keys are the State level maps. There are no additional entries or default values. State Level Map The State level is a simple key/value map where keys are Form State State Names ( MscmpSystForms.Types.form_state_state_name/0 ) and the values are maps of component Form IDs ( MscmpSystForms.Types.form_id/0 ) as keys along with their configured component modes ( MscmpSystForms.Types.component_display_modes/0 ) for that given Feature/Mode/State combination. Examples Different form elements may take on different display properties as the state of the form evolves over time with changes in data or in response to user interactions. This function returns a nested map structure which, based on the examples from get_form_config/0 , might look like: %{ default : %{ default : %{ concrete_config_input : %{ component_mode : :visible } , concrete_config_submit_button : %{ component_mode : :visible } } , entry : %{ basic_form_state : %{ concrete_config_input : %{ component_mode : :entry } , concrete_config_submit_button : %{ component_mode : :entry } } } , view : %{ basic_form_state : %{ concrete_config_input : %{ component_mode : :visible } , concrete_config_submit_button : %{ component_mode : :visible } } } , processing_overrides : %{ concrete_config_input : [ :process_underway ] concrete_config_submit_button : [ :process_underway ] } } }","ref":"MscmpSystForms.html#c:get_form_modes/0","title":"MscmpSystForms.get_form_modes/0","type":"callback"},{"doc":"Builds current Component Configurations based on the Form Configuration and Form Modes definitions in combination with runtime values such as the current Form State and the current user's permission grants. Render configurations, also called Component Configurations in this documentation provide each component in the user interface instructions on how to render and what interactivity to accept from the user. The Component Configurations generated by this function are returned as a map of key/value pairs where the keys are the MscmpSystForms.Types.form_id/0 values of the user interface components and the values are MscmpSystForms.Types.ComponentConfig.t/0 structs defining the current rendering requirements of the components. Typically this map is merged into the assigns of the form so that components can retrieve the configurations at render time. Parameters module - the name of the MscmpSystForms implementing module which backs the form. feature - the Form State Feature to reference when building Component Configurations. mode - the Form State Mode to reference when building Component Configurations. state - the Form State State to reference when building Component Configurations. perms - the current user's applicable permission grants for the form.","ref":"MscmpSystForms.html#get_render_configs/5","title":"MscmpSystForms.get_render_configs/5","type":"function"},{"doc":"Initializes the MscmpSystForms standard assign attributes and readies the form for rendering. Typically this function is called in the implementation of the MscmpSystForms.preconnect_init/6 of the form once the user, the user permissions, and any starting data for the form has been resolved. This function must be called prior to any attempted rendering of the form as many user interface components expect values in the Standard Assign Attributes to be available. In addition to adding the Standard Assign Attributes, this function will process the Form Configurations ( MscmpSystForms.get_form_config/0 ) using the Form State parameters ( feature , mode , and state ) and the current user's permissions ( user_perms ) Standard Assign Attributes: msrd_instance_id - the identifier for any single instance of a running form. This supports the use case where a user logged into a single session may have multiple instances of the same form open accessing the same data, but desiring to also edit that data. In this case we only allow a single instance of the form to be in an editable mode, blocking all other instances, including other instances in the same session, from editing the data. msrd_session_name - the identifier for the user's authenticated session. This session name is a reference to the session record in the database which contains session oriented data and session management statistics such as expiration date/time. It is by having a valid, authenticated session identified by this value that the system knows that the user is authenticated. msrd_form_module - the MscmpSystForms behaviour implementing module which backs the form. msrd_original_data - the data backing the form at the time the form was initialized. This data does not change as user interacts with the form, including changing the form's data, allowing for comparisons, validations, and resets of changed data with the starting data. The original data is a struct as defined by the MscmpSystForms backing module where the keys are the binding ID's of the form data fields. Note that this data includes all form backing data without regard to the current user's data visibility permissions. msrd_current_data - the data backing the form including any changes made by the user or by the system in response to various interactions with the form. As the name suggests this is value represents the current state of the data and is the data that must pass any validation attempts and the data that will ultimately be saved to the database. This value is represented as a simple map of key/value pairs where the keys are the binding ID's of the form data fields. Note that this data includes all form backing data without regard to the current user's data visibility permissions. msrd_display_data - the data used to fill user interface form elements. This data is the same as the msrd_current_data except that values which are disallowed by the user data visibility permissions are excluded and the data is represented as a Phoenix.HTML.Form.t/0 value. msrd_feature - the currently prevailing form state feature. The &quot;feature&quot; is the highest level determinant of form state, which determines how some form user interface components present themselves or allow for interactivity. Typical examples of how the msrd_feature of a form might be used includes a single form supporting both sales quoting and sales ordering: while very similar there are differences in the functionality and elements required by these two activities and the msrd_feature would tell the form which mode was currently in use. The value is an atom. See MscmpSystForms.get_form_modes/0 for more information msrd_mode - the current mode of the form state. This is typically used to distinguish between &quot;view only&quot; form modes and &quot;maintenance&quot; form modes which allow a user to change data. The actual modes implemented by a form are not restricted to these purposes and may be arbitrarily defined as the form needs dictate. The current msrd_mode value is considered a subdivision of the current msrd_feature value; this means that the same msrd_mode value may appear to behave differently depending on the current value of the msrd_feature attribute. The value is an atom. See MscmpSystForms.get_form_modes/0 for more information msrd_state - the current form state within the msrd_mode . &quot;Form states&quot; are the most granular level at which form user interface behaviors are determined. This value supports functionality which allows for &quot;progressive entry&quot; style forms: forms which only allow certain user inputs to be made prior to allowing others which depend on the earlier values, for example. msrd_state values are subordinate to the prevailing msrd_mode value and as such the same msrd_state value may exhibit different behaviors for differing values of msrd_mode . The value is an atom. See MscmpSystForms.get_form_modes/0 for more information msrd_overrides - a list of the currently active processing overrides. As a user interacts with a form, there may be certain actions which result in longer running processes during which certain user interface interactions or data displays should become inactive or indicate some form of &quot;please wait&quot; message; the list of active processing overrides indicate that such processing exists so that user interface elements may respond as necessary. This list is maintained using the MscmpSystForms.start_processing_override/2 and MscmpSystForms.finish_processing_override/2 functions. msrd_user_perms - The relevant permission grants of the current user. This is a map conforming to the t:MscmpSystPerms.perm_grants/0 type. The permission grants are used as a filter for determining what the user may see in terms of data and do in terms of form functionality. Parameters socket_or_assigns - the socket or assigns for the current view. session_name - the name of the session. This value is usually set in prior to the view being called and is part of the parameters passed to the view. Ultimately this is the link between the users client and our richer sense of session available to the server side view logic. module - the name of the form module backing the form and implementing the MscmpSystForm behaviour. feature - the currently prevailing form state feature. See the msrd_feature Standard Assign Attribute description above for more. mode - the currently prevailing form state mode. See the msrd_mode Standard Assign Attribute description above for more. state - the currently prevailing form state. See the msrd_state Standard Assign Attribute description above for more. user_perms - the current user permission grants which apply to the form. See the msrd_user_perms Standard Assign Attributes discussion above for more. opts - this function accepts a number of optional parameters. The available options are: original_data - the starting form data, often times as drawn from the database. The data retained here does not reflect changes in the data by the user interacting with the form. All data backing the form is kept in this value without regard to the current user's data visibility permissions. The expected value for this option is the starting data as a struct defined by the form backing MscmpSystForms behaviour implementing module. The default value is an empty struct of the expected type. current_data - the current form data reflecting changes made due to user interactions which have not yet been committed to the database. The data here is the complete current data, without regard to the user's data visibility permissions. This data given for this parameter is expected to be a simple map based on the form backing MscmpSystForms implementing module. The default value is a map copied from the original_data option value. display_data - this option will ultimately set the msrd_display_data Standard Assign Attribute described above. For the purposes of init_assigns/8 , this value should be a reference to a MscmpSystForms.Types.data_validation_types/0 value which will process the data provided by the original_data and current_data options into the correct display data for the form, after having applied the user's data visibility permissions. overrides - this option allows the processing overrides list stored in msrd_overrides to be populated on initialization. This could be helpful if certain initialization processes themselves are expected to be long running. By default this option is set to an empty list.","ref":"MscmpSystForms.html#init_assigns/8","title":"MscmpSystForms.init_assigns/8","type":"function"},{"doc":"An initialization sequence run during the connected, second call to Phoenix.LiveView.mount/3 . This function currently doesn't have any specific or well defined &quot;typical use cases&quot; as does preconnect_init/6 . It is assumed that any required data or configurations were initially set using preconnect_init/6 and are available in the socket assigns passed to Phoenix.LiveView.mount/3 . Parameters socket_or_assigns - the socket or assigns for the current view.","ref":"MscmpSystForms.html#c:postconnect_init/1","title":"MscmpSystForms.postconnect_init/1","type":"callback"},{"doc":"An initialization sequence run during first, static mount process. This callback is intended to define a function called in the first, static Phoenix.LiveView.mount/3 . While preconnect_init/6 can encapsulate any logic necessary during this phase of initialization, we would typically see the following activities handled: The capture of socket values passed to Phoenix.LiveView.mount/3 , such as session_name in preparation for calling init_assigns/8 . The resolution of user permissions required by the form. The loading of backing data from the database for the view or maintenance of existing data, or defaulted data in the case of new record creation. Initialization of the Standard Assign Attributes using init_assigns/8 . Naturally, while these would be typical activities to perform in preconnect_init/6 , they are not required not is this callback limited to running these functions. Truly, whatever makes sense for the form to process during this stage of the form life-cycle is acceptable. Parameters socket_or_assigns - the socket or assigns for the current view. session_name - the name of the session. This value is usually set in prior to the view being called and is part of the parameters passed to the view. Ultimately this is the link between the users client and our richer sense of session available to the server side view logic. feature - the currently prevailing form state feature. Typically this value is passed to init_assigns/8 for further processing. mode - the currently prevailing form state mode. Typically this value is passed to init_assigns/8 for further processing. state - the currently prevailing form state. Typically this value is passed to init_assigns/8 for further processing. opts - the options which might be used here will depended on the how this callback is implemented for the form. Since we often call init_assigns/8 from preconnect_init/6 , the options will simply be the same as those and just passed to init_assigns/8 .","ref":"MscmpSystForms.html#c:preconnect_init/6","title":"MscmpSystForms.preconnect_init/6","type":"callback"},{"doc":"Rebuilds component configuration assigns updating the configurations driving user interface rendering. This function needs to be called after settings which should alter the renderable Component Configurations. For example, changing the form's current Form State (feature, mode, or state) will change how the user interface components are rendered; after the Form State has been changed this function must be called to rebuild the component configuration assigns that actually drive the rendering of those components. Activities requiring the Component Configurations assigns to be rebuilt include: Changing the msrd_feature , msrd_mode , or msrd_state Form State values. Updating the msrd_user_perms value. Most other operations, such as processing form data changes don't require Component Configuration rebuilding as they work within the existing Component Configurations. Rebuilding the Component Configuration assigns is a somewhat expensive process and to avoid over-processing these rebuilds its recommended that all changes which require a Component Configuration rebuild be performed prior to calling rebuild_component_assigns/1 .","ref":"MscmpSystForms.html#rebuild_component_assigns/1","title":"MscmpSystForms.rebuild_component_assigns/1","type":"function"},{"doc":"A convenience function which sets the Form State State value on the appropriate Standard Assign Attribute. This allows only updating the Form State State value of the form, leaving the Form State Feature and Mode values unchanged. See set_form_state/4 for more information and caveats. Parameters socket_or_assigns - the socket or assigns for the current view. state - the new Form State State to set for the form.","ref":"MscmpSystForms.html#set_form_state/2","title":"MscmpSystForms.set_form_state/2","type":"function"},{"doc":"A convenience function which sets the Form State Mode and State values on the appropriate Standard Assign Attributes. This allows only updating the Form State Mode and State values of the form, leaving the Form State Feature value unchanged. See set_form_state/4 for more information and caveats. Parameters socket_or_assigns - the socket or assigns for the current view. mode - the new Form State Mode to set for the form. state - the new Form State State to set for the form.","ref":"MscmpSystForms.html#set_form_state/3","title":"MscmpSystForms.set_form_state/3","type":"function"},{"doc":"A convenience function which sets the Form State Feature, Mode, and State values on the appropriate Standard Assign Attributes. Note Using this function does not result in the regeneration of Component Configurations. This is not done to avoid regenerating Component Configurations multiple times unnecessarily. You must explicitly regenerate the Component Configuration for changes made by this function to be rendered correctly. This is typically done by calling rebuild_component_assigns/1 some time after this function has been called. For more see MscmpSystForms.init_assigns/8 . Parameters socket_or_assigns - the socket or assigns for the current view. feature - the new Form State Feature to set for the form. mode - the new Form State Mode to set for the form. state - the new Form State State to set for the form.","ref":"MscmpSystForms.html#set_form_state/4","title":"MscmpSystForms.set_form_state/4","type":"function"},{"doc":"Adds a processing override to the active overrides list. Some user interface components are configured to change their presentation and interactivity when certain, possibly long running, processes are underway. This function adds the value of the override parameter to the active processes list allowing components interest in that processing state to respond accordingly. Parameters socket_or_assigns - the socket or assigns for the current view. override - the name of the processing override to activate.","ref":"MscmpSystForms.html#start_processing_override/2","title":"MscmpSystForms.start_processing_override/2","type":"function"},{"doc":"Converts a form data Changeset into a Phoenix.HTML.Form.t/0 struct after having applied the current user's data visibility permissions. Once the current form's data has been validated it must be turned into a form that can be rendered. This function basically wraps the Phoenix.Ecto implementation of the Phoenix.HTML.FormData.to_form/2 function so that we can apply user data visibility permission to the data prior to the conversion of that data into a renderable Phoenix.HTML.Form.t/0 struct. Parameters changeset - an Ecto.Changeset.t/0 struct representing the validated data with which to build the form. Typically this Changeset will be generated either by validate_save/2 or validate_post/2 . perms - the current user's permission grants as recorded in the Standard Assign Attribute msrd_user_perms . See init_assigns/8 for more. opts - while not typically used, there are optional parameters which are passed to the Phoenix.HTML.FormData.to_form/2 function. The available options are documented at Phoenix.HTML.Form.form_for/4 . The options here have slightly different names to avoid naming collisions. component_id - the same as the id option of Phoenix.HTML.Form.form_for/4 . component_method - the same as the method option of Phoenix.HTML.Form.form_for/4 . component_multipart - the same as the multipart option of Phoenix.HTML.Form.form_for/4 . component_csrf_token - the same as the csrf_token option of Phoenix.HTML.Form.form_for/4 . component_errors - the same as the errors option of Phoenix.HTML.Form.form_for/4 .","ref":"MscmpSystForms.html#to_form/3","title":"MscmpSystForms.to_form/3","type":"function"},{"doc":"Sets the state of MscmpSystForms.WebComponents.msvalidated_button/1 components. Validated buttons exist in one of three states defined by MscmpSystForms.Types.msvalidated_button_states/0 . This function will set the state of the validated button identified by the form_id parameters to the state identified by the button_state parameters. Parameters socket_or_assigns - the socket or assigns for the current view. form_id - the identifier of the component to update. See MscmpSystForms.get_form_config/0 for more about form configuration attributes. button_state - the state to which the validated button component should be set. Any value defined by the MscmpSystForms.Types.msvalidated_button_states/0 type is valid for this purpose.","ref":"MscmpSystForms.html#update_button_state/3","title":"MscmpSystForms.update_button_state/3","type":"function"},{"doc":"Updates the display form data with new values. The display data of the form, which represents the form's backing data after the application of effective user permissions to purge values that the user is not entitled to see, is set using this function. The data is stored in the view's assigns as a Phoenix.HTML.Form.t/0 value which is then passed to the view for rendering. Parameters socket_or_assigns - the socket or assigns for the current view. display_data - this option contains either the new display data to set and with which to update the form or indicates the kind of data validation to perform on the assigns stored data ( msrd_original_data &amp; msrd_current_data ; see MscmpSystForms.init_assigns/8 for more). One method for setting the display data is to pass this option to the function using actual data. This data can take the form of either a Ecto.Changeset.t/0 value or a Phoenix.HTML.Form.t/0 value. If a Changeset is passed, the function will automatically process it into a Phoenix.HTML.Form.t/0 struct, applying the permissions currently set in the msrd_user_perms Standard Assigns Attribute to filter the data. If the value to be passed in this option is a Phoenix.HTML.Form.t/0 value, the struct should have been generated using MscmpSystForms.to_form/3 so that the user data visibility permissions will have been allied. The second method is to pass display_data as a value referencing a display data validation type ( MscmpSystForms.Types.data_validation_types/0 ). When this method is used, the values of the msrd_current_data and msrd_original_data are validated using the standard validation functions ( MscmpSystForms.validate_save/2 and MscmpSystForms.validate_post/2 ) and then processed into a Phoenix.HTML.Form.t/0 value to save as the new msrd_display_data value. Either of the validation types will result in the application of user data visibility permissions per the msrd_user_perms Standard Assigns Attribute. opts - this function defines some optionally required parameters which are dependent on the display_data parameter. When the display_data value is passed as a MscmpSystForms.Types.data_validation_types/0 allowed value the following are required: original_data - a struct of values representing the starting data initialized on initial form loading and absent any changes the user may have made and not yet committed to the database. This value should be available in the standard assigns for MscmpSystForms based forms. current_data - a map of values representing the current data backing the form. This data is complete (unfiltered by user data related permissions) and includes any edits made by the user and not yet committed to the database. This value is available in the standard assigns for MscmpSystForms based forms. module - the name of the form module implementing the MscmpSystForm behaviour and the functions to validate the Changeset.","ref":"MscmpSystForms.html#update_display_data/3","title":"MscmpSystForms.update_display_data/3","type":"function"},{"doc":"An Ecto.Changeset.t/0 generating function which validates that a given set of data is sufficient for posting as a fully fledged business transaction. This function serves to validate that a form's data fully meets the requirements of a complete business transaction. In cases where less-than-ready works in progress should be saveable, the validate_save/2 function should be called instead. Parameters original_data - a representation of the starting data using the MscmpSystForms implementing struct backing the form. Setting this value correctly allows the Changeset to correctly identify changes to the data. current_data - a map based representation of the current data which is to be validated during the creation of the Changeset.","ref":"MscmpSystForms.html#c:validate_post/2","title":"MscmpSystForms.validate_post/2","type":"callback"},{"doc":"An Ecto.Changeset.t/0 generating function which validates that a given set of data is sufficient for simply saving to the database. In many cases in business applications, it is possible to save &quot;work in progress&quot; to the database without needing to post a fully committed business transaction. For example, a purchase order may be authored over the course of a few days before it is final and ready to send to the vendor; in this case we could validate just enough data to make the in-progress purchase order distinguishable from other similar orders while not requiring a fully executable order and thus allow the author to save their work to the database. Later, a transaction ready to be committed in the business sense (&quot;posting&quot;) can call validate_post/2 to validate that the transaction may be posted as a valid business transaction. Often times there is no distinction between the &quot;savable&quot; and &quot;postable&quot; state. In these cases, it's best to write the main validate logic in the validate_post/2 function and simply delegate this function to that one; raising an exception in this function is also an option to force the correct call. Parameters original_data - a representation of the starting data using the MscmpSystForms implementing struct backing the form. Setting this value correctly allows the Changeset to correctly identify changes to the data. current_data - a map based representation of the current data which is to be validated during the creation of the Changeset.","ref":"MscmpSystForms.html#c:validate_save/2","title":"MscmpSystForms.validate_save/2","type":"callback"},{"doc":"A set of web components which define the standard application user interface &quot;widgets&quot; from which the application is built.","ref":"MscmpSystForms.WebComponents.html","title":"MscmpSystForms.WebComponents","type":"module"},{"doc":"Displays a simple button with which the user may interact.","ref":"MscmpSystForms.WebComponents.html#msbutton/1","title":"MscmpSystForms.WebComponents.msbutton/1","type":"function"},{"doc":"A generalized container component which provides layouts for and contains other user interface elements.","ref":"MscmpSystForms.WebComponents.html#mscontainer/1","title":"MscmpSystForms.WebComponents.mscontainer/1","type":"function"},{"doc":"A specialized container component for containing extended text.","ref":"MscmpSystForms.WebComponents.html#msdisplay/1","title":"MscmpSystForms.WebComponents.msdisplay/1","type":"function"},{"doc":"A utility component which displays an exclamation mark in a circle in the presence of errors.","ref":"MscmpSystForms.WebComponents.html#msfield_errors/1","title":"MscmpSystForms.WebComponents.msfield_errors/1","type":"function"},{"doc":"A specialized container which defines an HTML form.","ref":"MscmpSystForms.WebComponents.html#msform/1","title":"MscmpSystForms.WebComponents.msform/1","type":"function"},{"doc":"A small utility component which gives regularized access to &quot;Heroicons&quot;.","ref":"MscmpSystForms.WebComponents.html#msicon/1","title":"MscmpSystForms.WebComponents.msicon/1","type":"function"},{"doc":"A component which provides the capability to include short reference documentation in a form.","ref":"MscmpSystForms.WebComponents.html#msinfo/1","title":"MscmpSystForms.WebComponents.msinfo/1","type":"function"},{"doc":"A component which accepts a wide range of textually oriented user input.","ref":"MscmpSystForms.WebComponents.html#msinput/1","title":"MscmpSystForms.WebComponents.msinput/1","type":"function"},{"doc":"A component which defines a list of entries or other components.","ref":"MscmpSystForms.WebComponents.html#mslist/1","title":"MscmpSystForms.WebComponents.mslist/1","type":"function"},{"doc":"Creates an list entry within an established mslist/1 .","ref":"MscmpSystForms.WebComponents.html#mslistitem/1","title":"MscmpSystForms.WebComponents.mslistitem/1","type":"function"},{"doc":"Generates a modal window.","ref":"MscmpSystForms.WebComponents.html#msmodal/1","title":"MscmpSystForms.WebComponents.msmodal/1","type":"function"},{"doc":"A container component which typically encapsulates its contents with a border and provides the section a label.","ref":"MscmpSystForms.WebComponents.html#mssection/1","title":"MscmpSystForms.WebComponents.mssection/1","type":"function"},{"doc":"Provides a three state button where the state is meant to be determined by some external condition, such as a form validation.","ref":"MscmpSystForms.WebComponents.html#msvalidated_button/1","title":"MscmpSystForms.WebComponents.msvalidated_button/1","type":"function"},{"doc":"","ref":"MscmpSystForms.Types.html","title":"MscmpSystForms.Types","type":"module"},{"doc":"The identifier type for data binding identifiers. Data binding identifiers are used to identify data fields in Ecto Changesets, t:Phoenix.HTML.form.t/0 representations of data, form parameters as returned on submission, and in MscmpSystForms.Types.FormConfig.t/0 form configurations. All of these representations which are used in different contexts will represent the same data and this binding_id is the name which identifies the data across these logical contexts.","ref":"MscmpSystForms.Types.html#t:binding_id/0","title":"MscmpSystForms.Types.binding_id/0","type":"type"},{"doc":"A structure defining the different kinds of display mode data which can be communicated to a user interface component. User interface components can be configured with a variety of display options, called &quot;modes&quot;. Between the functions which generate the effective modes for the user interface and the user interface components themselves there must be a standard way to communicate and this type defines the structure of that communication. It is worth noting that the Component will receive its display modes in data with this structure.","ref":"MscmpSystForms.Types.html#t:component_display_modes/0","title":"MscmpSystForms.Types.component_display_modes/0","type":"type"},{"doc":"The returned data type of the MscmpSystForms.get_component_info/2 function. The type identifies the specific returned textual information describing the component and configured in the Form Configurations. See MscmpSystForms.get_form_config/0 for more.","ref":"MscmpSystForms.Types.html#t:component_info/0","title":"MscmpSystForms.Types.component_info/0","type":"type"},{"doc":"Component level modes which govern the behavior of components in terms of interactivity, whether or not they may display data, and even if the component is visible to users or present in the layout. Each component is designed to respond appropriately when one of the following component modes are specified. :removed - A component in this mode will not be visible and will not take space in the layout of a view. :hidden - When a component is in this mode, the component is hidden fro the user, but will take space in the layout of the view as though it were present. :cleared - The cleared component mode allows components to be rendered into the layout, but input related components will not display any of their associated data and will be disabled for any user interactivity. This is used primarily when the user may know that a given field exists, but does not have permission to view the data associated with the field. :processing - Used when some long running application process involving the data of the form or component has started, but not yet finished. A component in processing mode will be disabled from user interaction and will likely change its display characteristics as appropriate for the processing state. :visible - For use when a component should be present and visible on the screen and any associated data should be visible to the user, but the component should not accept user interactions. Informally speaking this is the mode which enables a &quot;view only&quot; presentation of a component. :entry - This component mode allows the component and its associated data to be visible to the user as well as allows the user to interact with any functionality, such as changing the data value or clicking a button, etc. Informally speaking this is the &quot;edit mode&quot; component mode.","ref":"MscmpSystForms.Types.html#t:component_modes/0","title":"MscmpSystForms.Types.component_modes/0","type":"type"},{"doc":"Defines the acceptable validation type values that can be passed in the display_data parameter of MscmpSystForms.init_assigns/8 and MscmpSystForms.update_display_data/3 .","ref":"MscmpSystForms.Types.html#t:data_validation_types/0","title":"MscmpSystForms.Types.data_validation_types/0","type":"type"},{"doc":"A standardized set of modes which govern the styling of MscmpSystForms defined web components. :deemphasis - Used in cases where we want to specific reduce attention to a give element. For example :deemphasis might be used in cases where a web component is disabled for entry. The reduction in &quot;presence&quot; is the greatest compared amongst all display modes which reduce visual presence. :reference - For reducing attention to informational content as compared to actionable elements such as input fields and their labels. In this case we want a visually &quot;present&quot; element, but not one so visually pronounced that is distracts from more important elements. :normal - This display mode is the primary choice of normal input components as well as their labels. This is true when the elements are active and actionable, but require no greater attention that most other elements with with they are displayed. :emphasis - Used for elements which are active and are of greater importance or require more pronounced attention than other elements of the same class. For example, a required input field and its label may be given this display mode so they stand out from all other entry fields. Use of this display mode should be carefully considered as if everything is emphasized then nothing is. :warning - Elements which are in a warning state and where the warning state requires greater attention than normal screen elements. This display mode will typically change various colored elements to the established warning color. :alert - When elements in the interface require heightened attention and are either in an error state or in conditions where greater attention than a warning is required. Colored elements will typically assume the established alert color when this display mode is set. :approve - A normal attention display mode where colored elements will assume the established approval colors. :deny - A normal attention display mode where colored elements will assume the established denial colors. :info - A normal attention display mode where colored elements will assume the established &quot;information&quot; color scheme.","ref":"MscmpSystForms.Types.html#t:display_modes/0","title":"MscmpSystForms.Types.display_modes/0","type":"type"},{"doc":"Defines a type for identifying specific elements in user interface forms. Under some form processing functions, particularly those dealing with creating web user interfaces, form_id values may be converted to binary/0 representations as they are also used for HTML element id attributes (either directly or as modified to identify sub-elements of user interface components.)","ref":"MscmpSystForms.Types.html#t:form_id/0","title":"MscmpSystForms.Types.form_id/0","type":"type"},{"doc":"The structure of data representing Components and their display modes within form_state_states/0 structured data.","ref":"MscmpSystForms.Types.html#t:form_state_components/0","title":"MscmpSystForms.Types.form_state_components/0","type":"type"},{"doc":"Defines the type used to express Form State Feature names.","ref":"MscmpSystForms.Types.html#t:form_state_feature_name/0","title":"MscmpSystForms.Types.form_state_feature_name/0","type":"type"},{"doc":"The expressed data structure of Form State Feature configurations. Each Form State Feature defines several different points of configuration. First a :default set of component configurations which act as a fallback when a specific Mode/State combination do not fully address a component's configuration themselves. When the :default component configuration also doesn't address a component, the component_display_modes/0 of last resort is used (currently: %{component_mode: :cleared} ). Next we define the :processing_overrides that each component should respond to when active. Finally we define the Modes and States for each named Feature. We expect that each Mode will be represented with a key in this map using the Mode's name; the value will be a map in the form dictated by form_state_modes/0 . See MscmpSystForms.get_form_modes/0 for more.","ref":"MscmpSystForms.Types.html#t:form_state_features/0","title":"MscmpSystForms.Types.form_state_features/0","type":"type"},{"doc":"Defines the type used to express Form State Mode names.","ref":"MscmpSystForms.Types.html#t:form_state_mode_name/0","title":"MscmpSystForms.Types.form_state_mode_name/0","type":"type"},{"doc":"The structure defining how Form State Modes are expressed within the Form State defined by form_states/0 . Each Form State Mode definition returned by MscmpSystForms.get_form_modes/0 should be a map of key/value pairs where the key is the Form State Mode Name and the values are each a map of the defined Form State States for that Mode. See MscmpSystForms.get_form_modes/0 for more.","ref":"MscmpSystForms.Types.html#t:form_state_modes/0","title":"MscmpSystForms.Types.form_state_modes/0","type":"type"},{"doc":"Defines how Components are linked to the Processing Overrides to which they are interested in responding. Processing overrides are a mechanism to identify that certain processes that are expected to be long running are active. Components in turn can respond to the processes they are watching becoming active as they require (usually the component becomes inactive while the process is active).","ref":"MscmpSystForms.Types.html#t:form_state_overrides/0","title":"MscmpSystForms.Types.form_state_overrides/0","type":"type"},{"doc":"The type which is used to represent the name of Form State states.","ref":"MscmpSystForms.Types.html#t:form_state_state_name/0","title":"MscmpSystForms.Types.form_state_state_name/0","type":"type"},{"doc":"The structure of each individual Form State as defined within the form_states/0 . Form State State definitions returned by MscmpSystForms.get_form_modes/0 are expected to come as a map of key/value pairs where the key is the name of the Form State State being defined ( form_state_state_name/0 ) and the value is a map of components which define their display modes for the State. See MscmpSystForms.get_form_modes/0 for more.","ref":"MscmpSystForms.Types.html#t:form_state_states/0","title":"MscmpSystForms.Types.form_state_states/0","type":"type"},{"doc":"The data structure describing the configuration of Form States as returned by MscmpSystForms.get_form_modes/0 . Form State configurations are returned as a map of &quot;Features&quot; where each Feature defines its Modes, States, Defaults, and Processing Overrides. Each Feature in the Form State is represented in the map using its own name as the key. The common practice is that if a form only supports a single Feature, the Feature should be named :default ; otherwise the Feature Name is arbitrary, but should be descriptive.","ref":"MscmpSystForms.Types.html#t:form_states/0","title":"MscmpSystForms.Types.form_states/0","type":"type"},{"doc":"Identifies the available states that an MscmpSystForms.WebComponents.msvalidated_button/1 might take. :action - this state indicates that the validating conditions have been met and that the button's action may be invoked at user convenience. :processing - indicates that an active process which prevents the button from correctly reflecting any state other than it is waiting is currently underway. The button will not accept user interaction at this point. :message - indicates that the validating condition for the button is not yet satisfied. Any user interaction with the button (clicking it) will result in a message indicating that there are unmet conditions.","ref":"MscmpSystForms.Types.html#t:msvalidated_button_states/0","title":"MscmpSystForms.Types.msvalidated_button_states/0","type":"type"},{"doc":"A type for naming permissions. Forms in the system will at a display level need to have awareness and functionality to respect permissions.","ref":"MscmpSystForms.Types.html#t:permission_name/0","title":"MscmpSystForms.Types.permission_name/0","type":"type"},{"doc":"Defines the type of Processing Override Names. Processing overrides are a mechanism to identify that certain processes that are expected to be long running are active. Components in turn can respond to the processes they are watching becoming active as they require (usually the component becomes inactive while the process is active).","ref":"MscmpSystForms.Types.html#t:processing_override_name/0","title":"MscmpSystForms.Types.processing_override_name/0","type":"type"},{"doc":"Establishes the expected data structure of the MscmpSystForms.get_render_configs/5 function return value. The MscmpSystForms.get_render_configs/5 function returns the currently renderable configurations for each Component as a map of key/value pairs where the key is the t:form_id() of the Component and the value is a Component Configuration using the MscmpSystForms.Types.ComponentConfig.t/0 data structure.","ref":"MscmpSystForms.Types.html#t:render_configs/0","title":"MscmpSystForms.Types.render_configs/0","type":"type"},{"doc":"Defines the type of the Session Name. The Session Name is usually generated via in the router's authentication related plug pipelines. The Session Name is added to the user's browser session and becomes the link between that browser session and the extended session information stored server side in the database.","ref":"MscmpSystForms.Types.html#t:session_name/0","title":"MscmpSystForms.Types.session_name/0","type":"type"},{"doc":"A definition of the expected Socket or Assigns parameter used in Phoenix. The Phoenix Framework has a number of functions which accept Sockets and Assigns from different sources which Phoenix generates, but Phoenix doesn't formalize this into any sort of typespec. Our concept is the same as Phoenix except that we prefer to have documented types, even if they are limited test/compile/run time value.","ref":"MscmpSystForms.Types.html#t:socket_or_assigns/0","title":"MscmpSystForms.Types.socket_or_assigns/0","type":"type"},{"doc":"An essential data type returned by the system using the MscmpSystForms.get_render_configs/5 function. That function returns a full form aggregate render configuration which is a combination of the developer created MscmpSystForms.Types.FormConfig.t/0 values and various values determined at runtime such as the current form state, active processing overrides, and current user permissions. This would be called a &quot;Render Time&quot; concern/derived configuration. The ComponentConfig values created by MscmpSystForms.get_render_configs/5 just described are passed to the view where each Web Component will respond to its ComponentConfig value in order to meet the then prevailing view requirements. Note This struct will not typically be created or used directly by a developer creating user forms. In this sense this struct could be considered an internal implementation concern which shouldn't be part of the public documentation. However, developers creating components which need to participate in MscmpSystForms form processing will need to know how to make their components respond to ComponentConfig values so we do include it in the documentation here.","ref":"MscmpSystForms.Types.ComponentConfig.html","title":"MscmpSystForms.Types.ComponentConfig","type":"module"},{"doc":"Defines a struct which encapsulates runtime component configurations using MscmpSystForms.get_render_configs/5 . Fields form_id - identifies the user interface form element to which the component configuration will be applied. Note that whereas MscmpSystForms.Types.FormConfig.t/0 allows configurations of virtual or abstract components, these configurations will never appear as a MscmpSystForms.Types.ComponentConfig.t/0 value. Only concrete components with a form_id value are allowed to represented by component configurations. binding_id - for user interface elements which display application data to identify the data field from which to draw values using this identifier. If the binding_id is nil then the element will not be bound to a field in the form's backing data. permission - the identifier of the permission which determined may have changed the modes value which control element rendering. This value will either be the permission set explicitly for field or that which the element inherited through its MscmpSystForms.Types.FormConfig parent. This value may also be nil in which case permissions didn't influence the modes value because no permissions were defined to apply. label - if set, this value will determine the label text for any Web Component which can display a label, such as MscmpSystForms.WebComponents.msinput/1 . If the component's title attribute is set directly in the view, it will override any value here. label_link - the label of a user interface element may optionally define a URL to link to when clicking the label, such as a link to relevant documentation. When this value is not nil , the link is the URL to the resource to access; when nil the label is rendered without a link. ( Note that label_link is not yet implemented in most components. ) info - in some situations, abbreviated additional information for a user interface element is made available to the user, for example via the MscmpSystForms.WebComponent.msinfo/1 web component. This attribute configures the text that is displayed to the user in these scenarios. If the value is nil then no text is displayed even if it could be. button_state - if the component being configured by this value is a MscmpSystForms.WebComponents.msvalidated_button/1 component, the button_state value will indicate the current display state of the button. See MscmpSystForms.Types.msvalidated_button_states/0 for the available states. overrides - a list of currently active processing overrides. A process override is a state which can be set for the form which simply indicates that some possibly long running application operation has been started, but is not yet finished. See MscmpSystForms.start_processing_override/2 for more about processing overrides. The form and its components can respond to an active processing override by, for example, changing their display and interactivity characteristics until the processing override condition ends. If there are no processing overrides active, this value will be an empty list. modes - the currently computed display modes for the component. The display modes are computed by assessing the prevailing runtime form state and user permissions to determine the behavior of the component at render time. These modes are then used by the component when creating the view to render.","ref":"MscmpSystForms.Types.ComponentConfig.html#t:t/0","title":"MscmpSystForms.Types.ComponentConfig.t/0","type":"type"},{"doc":"A struct used by developers to define the abstract structure and configuration details of user interface forms and their elements including their permissions, data bindings, text strings, as well as their child elements which may inherit certain properties such as permissions. This would be called a &quot;Definition Time&quot; concern/configuration. Note that while it is most typical for form configurations to be associated directly with specific user interface elements, the configuration system allows for grouping form configuration entries which do not related directly a specific user interface element and exist purely to serve as parent to other form configurations so that those children can inherit the parent's properties. A common example of this is most forms define an abstract top level parent form configuration which defines the default permission for all other form elements to inherit from. Not all elements on a form must be represented by a FormConfig value, however any element which must respond to runtime changes in form state, processing overrides, or current user permissions must have at least a FormConfig value defining its form_id value.","ref":"MscmpSystForms.Types.FormConfig.html","title":"MscmpSystForms.Types.FormConfig","type":"module"},{"doc":"Defines the attributes available to the developer to create an abstract form definition. Fields form_id - identifies the user interface form element to which the configuration will be applied. If this value is nil then the configuration won't refer to specific element in the user interface, but is a virtual or abstract configuration which may serve as parent to other concrete element backing configurations. Note that elements with FormConfigs defined with nil form_id values will not appear at all in render configurations. binding_id - for user interface elements which display application data to identify the data field from which to draw values using this identifier. If the binding_id is nil then the element will not be bound to a field in the form's backing data. permission - the identifier of the permission which this form element will test for element access when rendering the form, displaying data, and permitting user interaction if the element being configured allows for interaction. This value will be inherited by any child of a configuration that doesn't specify its own permission value. label - if the user interface element is backed by a component which displays a label, such as an MscmpSystForms.WebComponents.msinput/1 component, the text of the label may be set using this value. If this value is nil either the label will be blank, not rendered, or determined by directly setting the component's title value directly in the view layer. Note that component's title attribute can override the value set in the configuration using this configuration. label_link - the label of a user interface element may optionally define a URL to link to when clicking the label, such as a link to relevant documentation. When this value is not nil , the link is the URL to the resource to access; when nil the label is rendered without a link. ( Note that label_link is not yet implemented in most components. ) info - in some situations, abbreviated additional information for a user interface element is made available to the user, for example via the MscmpSystForms.WebComponent.msinfo/1 web component. This attribute configures the text that is displayed to the user in these scenarios. If the value is nil then no text is displayed even if it could be. button_state - for user interface buttons of type MscmpSystForms.WebComponents.msvalidated_button/1 , this attribute configures the default button state. The available values are defined by the type MscmpSystForms.Types.msvalidated_button_states/0 . children - A form configuration may optionally identify child configurations which will inherit certain attributes and other traits from the parent. Naturally, an element should never be added as a child to multiple parent configurations; doing so will result in undefined behaviors. Examples of attributes and traits that can be inherited through parent/child relationships defined in this field include permissions and component modes.","ref":"MscmpSystForms.Types.FormConfig.html#t:t/0","title":"MscmpSystForms.Types.FormConfig.t/0","type":"type"}]